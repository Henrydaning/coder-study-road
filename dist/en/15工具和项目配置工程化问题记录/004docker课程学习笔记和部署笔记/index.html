<!DOCTYPE html>
<html dir="ltr" lang="en-us" class="initial astro-OUAMJN2I">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Astro v2.0.1">

<link rel="icon" type="image/svg+xml" href="/favicon.svg">

<link rel="sitemap" href="/sitemap.xml">

<!-- Preload Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital@0;1&display=swap" rel="stylesheet">

<!-- Scrollable a11y code helper -->
<script src="/make-scrollable-code-focusable.js"></script>

<!-- This is intentionally inlined to avoid FOUC -->
<script>
	const root = document.documentElement;
	const theme = localStorage.getItem('theme');
	if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
		root.classList.add('theme-dark');
	} else {
		root.classList.remove('theme-dark');
	}
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-TEL60V1WM9" is:inline></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-TEL60V1WM9');
</script> -->
		<!-- Page Metadata --><link rel="canonical" href="https://astro.build/en/15%E5%B7%A5%E5%85%B7%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/004docker%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/">

<!-- OpenGraph Tags -->
<meta property="og:title" content="全栈记录之旅 🚀 全栈记录之旅">
<meta property="og:type" content="article">
<meta property="og:url" content="https://astro.build/en/15%E5%B7%A5%E5%85%B7%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/004docker%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/">
<meta property="og:locale" content="en-us">
<meta property="og:image" content="https://github.com/withastro/astro/blob/main/assets/social/banner-minimal.png?raw=true">
<meta property="og:image:alt" content="astro logo on a starry expanse of space, with a purple saturn-like planet floating in the right foreground">
<meta name="description" property="og:description" content="成长依旧，步履不停">
<meta property="og:site_name" content="全栈记录之旅">

<!-- Twitter Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="astrodotbuild">
<meta name="twitter:title" content="全栈记录之旅 🚀 全栈记录之旅">
<meta name="twitter:description" content="成长依旧，步履不停">
<meta name="twitter:image" content="https://github.com/withastro/astro/blob/main/assets/social/banner-minimal.png?raw=true">
<meta name="twitter:image:alt" content="astro logo on a starry expanse of space, with a purple saturn-like planet floating in the right foreground">

<!--
  TODO: Add json+ld data, maybe https://schema.org/APIReference makes sense?
  Docs: https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data
  https://www.npmjs.com/package/schema-dts seems like a great resource for implementing this.
  Even better, there's a React component that integrates with `schema-dts`: https://github.com/google/react-schemaorg
-->
		<title>
			全栈记录之旅 🚀 全栈记录之旅
		</title>
		
		
	<link rel="stylesheet" href="/_astro/_...slug_.a0ad6b47.css" /></head>

	<body class="astro-OUAMJN2I">
		<header class="astro-2W66RQV5">
	<a href="#article" class="sr-only focus:not-sr-only skiplink astro-DMGOOZ7Y"><span class="astro-DMGOOZ7Y">Skip to Content</span></a>
	<nav class="nav-wrapper astro-2W66RQV5" title="Top Navigation">
		<div class="menu-toggle astro-2W66RQV5">
			<style>astro-island,astro-slot{display:contents}</style><script>(self.Astro=self.Astro||{}).idle=t=>{const e=async()=>{await(await t())()};"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,200)},window.dispatchEvent(new Event("astro:idle"));var l;{const c={0:t=>t,1:t=>JSON.parse(t,o),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(JSON.parse(t,o)),5:t=>new Set(JSON.parse(t,o)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(JSON.parse(t)),9:t=>new Uint16Array(JSON.parse(t)),10:t=>new Uint32Array(JSON.parse(t))},o=(t,s)=>{if(t===""||!Array.isArray(s))return s;const[e,n]=s;return e in c?c[e](n):void 0};customElements.get("astro-island")||customElements.define("astro-island",(l=class extends HTMLElement{constructor(){super(...arguments);this.hydrate=()=>{if(!this.hydrator||this.parentElement&&this.parentElement.closest("astro-island[ssr]"))return;const s=this.querySelectorAll("astro-slot"),e={},n=this.querySelectorAll("template[data-astro-template]");for(const r of n){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(const r of s){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("name")||"default"]=r.innerHTML)}const a=this.hasAttribute("props")?JSON.parse(this.getAttribute("props"),o):{};this.hydrator(this)(this.Component,a,e,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),window.removeEventListener("astro:hydrate",this.hydrate),window.dispatchEvent(new CustomEvent("astro:hydrate"))}}connectedCallback(){!this.hasAttribute("await-children")||this.firstChild?this.childrenConnectedCallback():new MutationObserver((s,e)=>{e.disconnect(),this.childrenConnectedCallback()}).observe(this,{childList:!0})}async childrenConnectedCallback(){window.addEventListener("astro:hydrate",this.hydrate);let s=this.getAttribute("before-hydration-url");s&&await import(s),this.start()}start(){const s=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(Astro[e]===void 0){window.addEventListener(`astro:${e}`,()=>this.start(),{once:!0});return}Astro[e](async()=>{const n=this.getAttribute("renderer-url"),[a,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),i=this.getAttribute("component-export")||"default";if(!i.includes("."))this.Component=a[i];else{this.Component=a;for(const d of i.split("."))this.Component=this.Component[d]}return this.hydrator=r,this.hydrate},s,this)}attributeChangedCallback(){this.hydrator&&this.hydrate()}},l.observedAttributes=["props"],l))}</script><astro-island uid="Z1tJ5XG" component-url="/_astro/SidebarToggle.c7c67a70.js" component-export="default" renderer-url="/_astro/client.15ddb572.js" props="{&quot;class&quot;:[0,&quot;astro-2W66RQV5&quot;]}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;SidebarToggle&quot;,&quot;value&quot;:true}" await-children=""><button type="button" aria-pressed="false" id="menu-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg><span class="sr-only">Toggle sidebar</span></button></astro-island>
		</div>
		<div class="logo flex astro-2W66RQV5">
			<a href="/" class="astro-2W66RQV5">
				<svg class="logo" width="40" height="40" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
	<style>
		#flame {
			fill: var(--theme-text-accent);
		}

		#a {
			fill: var(--theme-text-accent);
		}
	</style>
	<title>Logo:文档中心</title>
	<path id="a" fill-rule="evenodd" clip-rule="evenodd" d="M163.008 18.929c1.944 2.413 2.935 5.67 4.917 12.181l43.309 142.27a180.277 180.277 0 00-51.778-17.53l-28.198-95.29a3.67 3.67 0 00-7.042.01l-27.857 95.232a180.225 180.225 0 00-52.01 17.557l43.52-142.281c1.99-6.502 2.983-9.752 4.927-12.16a15.999 15.999 0 016.484-4.798c2.872-1.154 6.271-1.154 13.07-1.154h31.085c6.807 0 10.211 0 13.086 1.157a16.004 16.004 0 016.487 4.806z">
	</path>
	<path id="flame" fill-rule="evenodd" clip-rule="evenodd" d="M168.19 180.151c-7.139 6.105-21.39 10.268-37.804 10.268-20.147 0-37.033-6.272-41.513-14.707-1.602 4.835-1.961 10.367-1.961 13.902 0 0-1.056 17.355 11.015 29.426 0-6.268 5.081-11.349 11.349-11.349 10.743 0 10.731 9.373 10.721 16.977v.679c0 11.542 7.054 21.436 17.086 25.606a23.27 23.27 0 01-2.339-10.2c0-11.008 6.463-15.107 13.974-19.87 5.976-3.79 12.616-8.001 17.192-16.449a31.024 31.024 0 003.743-14.82c0-3.299-.513-6.479-1.463-9.463z">
	</path>
</svg>
				<h1 class="astro-2W66RQV5">全栈记录之旅</h1>
			</a>
		</div>
		<div style="flex-grow: 1;" class="astro-2W66RQV5"></div>
		
		<div class="search-item astro-2W66RQV5">
			<astro-island uid="K4PRh" component-url="/_astro/Search.fc8f0463.js" component-export="default" renderer-url="/_astro/client.fd400d45.js" props="{}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;Search&quot;,&quot;value&quot;:true}" await-children=""><button type="button" class="search-input"><svg width="24" height="24" fill="none"><path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><span>Search</span><span class="search-hint"><span class="sr-only">Press </span><kbd>/</kbd><span class="sr-only"> to search</span></span></button></astro-island>
		</div>
	</nav>
</header>


		<main class="layout astro-OUAMJN2I">
			<aside id="grid-left" class="grid-sidebar astro-OUAMJN2I" title="Site Navigation">
				<nav aria-labelledby="grid-left" class="astro-KQNE5HRN">
	<ul class="nav-groups astro-KQNE5HRN">
		<li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">记录是学习的开始</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/en/introduction" class="astro-KQNE5HRN">
											全栈学习
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/zero" class="astro-KQNE5HRN">
											00 个人前端项目实战记录和链接
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/first" class="astro-KQNE5HRN">
											01 React 课程学习和问题笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/second" class="astro-KQNE5HRN">
											02 极客时间Vue课程学习和问题笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/third" class="astro-KQNE5HRN">
											03 掘金算法课程学习和问题笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/fourth" class="astro-KQNE5HRN">
											04 掘金 Uniapp 课程和Taro或原生小程序学习笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/fifth" class="astro-KQNE5HRN">
											05 leetcode 刷题记录每周
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/sixth" class="astro-KQNE5HRN">
											06 极客时间 Node 全栈记录
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/seventh" class="astro-KQNE5HRN">
											07 React 学习常见问题和笔记记录
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/eighth" class="astro-KQNE5HRN">
											08 vue 常见问题和学习记录
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/ninth" class="astro-KQNE5HRN">
											09 book 前端进阶知识学习图书笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/tenth" class="astro-KQNE5HRN">
											10 book 前端开发设计模式和开发实战笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/eleventh" class="astro-KQNE5HRN">
											11 elementplus 经典源码和实战学习和问题笔记
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/twelfth" class="astro-KQNE5HRN">
											12 前端开发经典库学习记录
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/thirteenth" class="astro-KQNE5HRN">
											13Koa 和 express 框架学习记录
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/fourteenth" class="astro-KQNE5HRN">
											14 前端图形化学习
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/fifteenth" class="astro-KQNE5HRN">
											15 工具和项目配置工程化问题记录
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/sixteenth" class="astro-KQNE5HRN">
											16 前端拓展知识学习
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/seventeenth" class="astro-KQNE5HRN">
											17 低代码学习和总结
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/eighteen" class="astro-KQNE5HRN">
											18 经验亮点汇总( 迁移中 )
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/others" class="astro-KQNE5HRN">
											其他常见问题
										</a>
									</li><li class="nav-link astro-KQNE5HRN">
										<a href="/en/notices" class="astro-KQNE5HRN">
											常用符号
										</a>
									</li>
						</ul>
					</div>
				</li><li class="astro-KQNE5HRN">
					<div class="nav-group astro-KQNE5HRN">
						<h2 class="astro-KQNE5HRN">其他说明</h2>
						<ul class="astro-KQNE5HRN">
							<li class="nav-link astro-KQNE5HRN">
										<a href="/en/page-4" class="astro-KQNE5HRN">
											自定义
										</a>
									</li>
						</ul>
					</div>
				</li>
	</ul>
</nav>

<script>
	window.addEventListener('DOMContentLoaded', () => {
		var target = document.querySelector('[aria-current="page"]');
		if (target && target.offsetTop > window.innerHeight - 100) {
			document.querySelector('.nav-groups').scrollTop = target.offsetTop;
		}
	});
</script>


			</aside>
			<div id="grid-main" class="astro-OUAMJN2I">
				<article id="article" class="content astro-J75B3YUS">
	<section class="main-section astro-J75B3YUS">
		<h1 class="content-title astro-J75B3YUS" id="overview">全栈记录之旅</h1>
		<nav class="block sm:hidden astro-J75B3YUS">
			<script>(self.Astro=self.Astro||{}).media=(s,a)=>{const t=async()=>{await(await s())()};if(a.value){const e=matchMedia(a.value);e.matches?t():e.addEventListener("change",t,{once:!0})}},window.dispatchEvent(new Event("astro:media"));</script><astro-island uid="ZEnWXH" component-url="/_astro/TableOfContents.a1e7e9c9.js" component-export="default" renderer-url="/_astro/client.15ddb572.js" props="{&quot;headings&quot;:[1,&quot;[[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;dockerjeninsgitlab部署记录\&quot;],\&quot;text\&quot;:[0,\&quot;docker+jenins+gitlab部署记录\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;1第一步linux系统部署文件下面放置一个docker-composeyml文件\&quot;],\&quot;text\&quot;:[0,\&quot;（1）第一步：linux系统部署文件下面放置一个docker-compose.yml文件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;一步一步来对于地址docker-nginx\&quot;],\&quot;text\&quot;:[0,\&quot;一步一步来：对于地址~/docker-nginx\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;docker学习\&quot;],\&quot;text\&quot;:[0,\&quot;docker学习\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;1docker简历\&quot;],\&quot;text\&quot;:[0,\&quot;1.Docker简历\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;为什么docker这么快\&quot;],\&quot;text\&quot;:[0,\&quot;为什么docker这么快\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;2docker核心组成\&quot;],\&quot;text\&quot;:[0,\&quot;2.Docker核心组成\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;四大组成对象\&quot;],\&quot;text\&quot;:[0,\&quot;四大组成对象。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;镜像\&quot;],\&quot;text\&quot;:[0,\&quot;镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器核心namepace和group\&quot;],\&quot;text\&quot;:[0,\&quot;容器（核心namepace和group）\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;网络cgroup\&quot;],\&quot;text\&quot;:[0,\&quot;网络(cgroup)\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;数据卷\&quot;],\&quot;text\&quot;:[0,\&quot;数据卷\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-engine\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Engine\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;容器化的实现\&quot;],\&quot;text\&quot;:[0,\&quot;容器化的实现\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-daemon和docker-cli\&quot;],\&quot;text\&quot;:[0,\&quot;docker daemon和docker CLI\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;3dokcer运行环境搭建\&quot;],\&quot;text\&quot;:[0,\&quot;3.Dokcer运行环境搭建\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;dokcer环境依赖版本要求\&quot;],\&quot;text\&quot;:[0,\&quot;Dokcer环境依赖版本要求\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;linux系统中安装docker\&quot;],\&quot;text\&quot;:[0,\&quot;linux系统中安装Docker\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;必须是--docker-is-running才能表明docker\&quot;],\&quot;text\&quot;:[0,\&quot;必须是： * Docker is running才能表明docker\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;ubuntu\&quot;],\&quot;text\&quot;:[0,\&quot;Ubuntu\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;解决docker-is-not-runing\&quot;],\&quot;text\&quot;:[0,\&quot;解决docker is not runing\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker正确安装和可用的标记\&quot;],\&quot;text\&quot;:[0,\&quot;docker正确安装和可用的标记\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;将子系统作为docker-client端连接远程docker-damaen服务\&quot;],\&quot;text\&quot;:[0,\&quot;将子系统作为docker client端连接远程docker damaen服务\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;修改镜像docker源头加快镜像拉取\&quot;],\&quot;text\&quot;:[0,\&quot;修改镜像docker源头，加快镜像拉取\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;注意如果拉去jenkins注意安装jdkjre\&quot;],\&quot;text\&quot;:[0,\&quot;注意如果拉去jenkins注意，安装jdk，jre\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;windows中使用docker原理\&quot;],\&quot;text\&quot;:[0,\&quot;windows中使用Docker原理\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;6镜像与容器\&quot;],\&quot;text\&quot;:[0,\&quot;6.镜像与容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker镜像\&quot;],\&quot;text\&quot;:[0,\&quot;Docker镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;查看镜像\&quot;],\&quot;text\&quot;:[0,\&quot;查看镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;镜像命令\&quot;],\&quot;text\&quot;:[0,\&quot;镜像命令\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器的生命周期\&quot;],\&quot;text\&quot;:[0,\&quot;容器的生命周期\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;主进程\&quot;],\&quot;text\&quot;:[0,\&quot;主进程\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;写时复制机制\&quot;],\&quot;text\&quot;:[0,\&quot;写时复制机制\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;7从镜像仓库获得镜像\&quot;],\&quot;text\&quot;:[0,\&quot;7.从镜像仓库获得镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;镜像仓库\&quot;],\&quot;text\&quot;:[0,\&quot;镜像仓库\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;获取镜像\&quot;],\&quot;text\&quot;:[0,\&quot;获取镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;dokcer-hub镜像仓库\&quot;],\&quot;text\&quot;:[0,\&quot;Dokcer Hub镜像仓库\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-hub搜索镜像\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Hub搜索镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;管理镜像\&quot;],\&quot;text\&quot;:[0,\&quot;管理镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker的参数识别\&quot;],\&quot;text\&quot;:[0,\&quot;Docker的参数识别\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;删除镜像\&quot;],\&quot;text\&quot;:[0,\&quot;删除镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;8运行和管理容器\&quot;],\&quot;text\&quot;:[0,\&quot;8.运行和管理容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器的创建和启动\&quot;],\&quot;text\&quot;:[0,\&quot;容器的创建和启动。\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;创建容器\&quot;],\&quot;text\&quot;:[0,\&quot;创建容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;启动容器\&quot;],\&quot;text\&quot;:[0,\&quot;启动容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;创建和启动进行合并的docker命令\&quot;],\&quot;text\&quot;:[0,\&quot;创建和启动进行合并的docker命令\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;管理容器\&quot;],\&quot;text\&quot;:[0,\&quot;管理容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;停止和删除容器\&quot;],\&quot;text\&quot;:[0,\&quot;停止和删除容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;进入容器内部\&quot;],\&quot;text\&quot;:[0,\&quot;进入容器内部\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;9为容器配置网络\&quot;],\&quot;text\&quot;:[0,\&quot;9.为容器配置网络\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器网络\&quot;],\&quot;text\&quot;:[0,\&quot;容器网络\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器docker的网络实现\&quot;],\&quot;text\&quot;:[0,\&quot;容器Docker的网络实现\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器互联重点打通nigixh和web应用通信\&quot;],\&quot;text\&quot;:[0,\&quot;！！！容器互联（重点：打通nigixH和web应用通信）\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;暴露端口\&quot;],\&quot;text\&quot;:[0,\&quot;！！！暴露端口\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;通过别名连接\&quot;],\&quot;text\&quot;:[0,\&quot;通过别名连接\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;管理网络\&quot;],\&quot;text\&quot;:[0,\&quot;管理网络\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;创建网络和指定网络加入容器\&quot;],\&quot;text\&quot;:[0,\&quot;！！！创建网络和指定网络加入容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;端口映射\&quot;],\&quot;text\&quot;:[0,\&quot;！！！端口映射\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;10管理和存储数据\&quot;],\&quot;text\&quot;:[0,\&quot;10.管理和存储数据\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;数据管理方式的实现\&quot;],\&quot;text\&quot;:[0,\&quot;数据管理方式的实现。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;挂载方式\&quot;],\&quot;text\&quot;:[0,\&quot;挂载方式：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;挂载文件到容器\&quot;],\&quot;text\&quot;:[0,\&quot;挂载文件到容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;注意挂载数据卷\&quot;],\&quot;text\&quot;:[0,\&quot;注意挂载数据卷\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;11保存和共享镜像\&quot;],\&quot;text\&quot;:[0,\&quot;11.保存和共享镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;提交容器更新\&quot;],\&quot;text\&quot;:[0,\&quot;提交容器更新\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;为镜像命名\&quot;],\&quot;text\&quot;:[0,\&quot;为镜像命名\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;12dockerfile创建镜像\&quot;],\&quot;text\&quot;:[0,\&quot;12.Dockerfile创建镜像？？\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;dockerfile\&quot;],\&quot;text\&quot;:[0,\&quot;Dockerfile\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;环境搭建与镜像构建\&quot;],\&quot;text\&quot;:[0,\&quot;环境搭建与镜像构建\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;常见-dockerfile-指令\&quot;],\&quot;text\&quot;:[0,\&quot;常见 Dockerfile 指令\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;from\&quot;],\&quot;text\&quot;:[0,\&quot;FROM\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;run\&quot;],\&quot;text\&quot;:[0,\&quot;RUN\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;entrypoint-和-cmd\&quot;],\&quot;text\&quot;:[0,\&quot;ENTRYPOINT 和 CMD\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;copy-和-add\&quot;],\&quot;text\&quot;:[0,\&quot;COPY 和 ADD\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;构建镜像\&quot;],\&quot;text\&quot;:[0,\&quot;构建镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;13dockerfile的使用技巧\&quot;],\&quot;text\&quot;:[0,\&quot;13.Dockerfile的使用技巧\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;构建中使用变量\&quot;],\&quot;text\&quot;:[0,\&quot;构建中使用变量\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;环境变量\&quot;],\&quot;text\&quot;:[0,\&quot;环境变量\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;临摹案例\&quot;],\&quot;text\&quot;:[0,\&quot;临摹案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;14常见的docker-hub的镜像\&quot;],\&quot;text\&quot;:[0,\&quot;14.常见的docker hub的镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;选择镜像和程序版本\&quot;],\&quot;text\&quot;:[0,\&quot;选择镜像和程序版本\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;15使用docker-compose管理容器\&quot;],\&quot;text\&quot;:[0,\&quot;15.使用Docker Compose管理容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;解决容器管理的问题\&quot;],\&quot;text\&quot;:[0,\&quot;解决容器管理的问题\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-compose\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Compose\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;linux安装-docker-composedocker-compose安装\&quot;],\&quot;text\&quot;:[0,\&quot;linux安装 Docker Compose:docker-compose安装\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;在-windows-和-macos-中的-docker-compose\&quot;],\&quot;text\&quot;:[0,\&quot;在 Windows 和 macOS 中的 Docker Compose\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-compose-的基本使用逻辑\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Compose 的基本使用逻辑\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;启动和停止\&quot;],\&quot;text\&quot;:[0,\&quot;启动和停止\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;容器命令\&quot;],\&quot;text\&quot;:[0,\&quot;容器命令\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;注意开机启动wsl配置\&quot;],\&quot;text\&quot;:[0,\&quot;注意开机启动WSL配置\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;16常用的-docker-compose-配置项\&quot;],\&quot;text\&quot;:[0,\&quot;16.！！！常用的 Docker Compose 配置项\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;首先\&quot;],\&quot;text\&quot;:[0,\&quot;首先\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;17编写-docker-compose-项目\&quot;],\&quot;text\&quot;:[0,\&quot;17.编写 Docker Compose 项目\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;设置项目的目录结构\&quot;],\&quot;text\&quot;:[0,\&quot;设置项目的目录结构。\&quot;]}]]&quot;],&quot;class&quot;:[0,&quot;astro-J75B3YUS&quot;]}" ssr="" client="media" opts="{&quot;name&quot;:&quot;TableOfContents&quot;,&quot;value&quot;:&quot;(max-width: 50em)&quot;}" await-children=""><h2 id="on-this-page-heading" class="heading">目录</h2><ul><li class="header-link depth-3"><a href="#dockerjeninsgitlab部署记录">docker+jenins+gitlab部署记录</a></li><li class="header-link depth-3"><a href="#docker学习">docker学习</a></li><li class="header-link depth-3"><a href="#1docker简历">1.Docker简历</a></li><li class="header-link depth-3"><a href="#2docker核心组成">2.Docker核心组成</a></li><li class="header-link depth-3"><a href="#3dokcer运行环境搭建">3.Dokcer运行环境搭建</a></li><li class="header-link depth-3"><a href="#windows中使用docker原理">windows中使用Docker原理</a></li><li class="header-link depth-3"><a href="#6镜像与容器">6.镜像与容器</a></li><li class="header-link depth-3"><a href="#7从镜像仓库获得镜像">7.从镜像仓库获得镜像</a></li><li class="header-link depth-3"><a href="#8运行和管理容器">8.运行和管理容器</a></li><li class="header-link depth-3"><a href="#9为容器配置网络">9.为容器配置网络</a></li><li class="header-link depth-3"><a href="#10管理和存储数据">10.管理和存储数据</a></li><li class="header-link depth-3"><a href="#11保存和共享镜像">11.保存和共享镜像</a></li><li class="header-link depth-3"><a href="#12dockerfile创建镜像">12.Dockerfile创建镜像？？</a></li><li class="header-link depth-3"><a href="#13dockerfile的使用技巧">13.Dockerfile的使用技巧</a></li><li class="header-link depth-3"><a href="#14常见的docker-hub的镜像">14.常见的docker hub的镜像</a></li><li class="header-link depth-3"><a href="#15使用docker-compose管理容器">15.使用Docker Compose管理容器</a></li><li class="header-link depth-3"><a href="#16常用的-docker-compose-配置项">16.！！！常用的 Docker Compose 配置项</a></li><li class="header-link depth-3"><a href="#17编写-docker-compose-项目">17.编写 Docker Compose 项目</a></li></ul></astro-island>
		</nav>
		<h3 id="dockerjeninsgitlab部署记录">docker+jenins+gitlab部署记录</h3>
<h4 id="1第一步linux系统部署文件下面放置一个docker-composeyml文件">（1）第一步：linux系统部署文件下面放置一个docker-compose.yml文件</h4>
<p>这里放在</p>
<h4 id="一步一步来对于地址docker-nginx">一步一步来：对于地址~/docker-nginx</h4>
<p>这里配置一个ngigx服务地址内容</p>
<p>启动.sh文件启动nginx服务</p>
<h3 id="docker学习">docker学习</h3>
<p>---docker原理说明
实际上docker只能在linux系统下运行，Windows下运行必要要支持Hyper-v
( 注：windows专业版本才有这个功能)。安装docker的时候会自动创建一个虚拟的linux系统，
后续的其他操作实际上是间接使用这个虚拟系统进行的）</p>
<p>---linux运行docker原理---
docker容器和宿主机共享linux kernel。为了让容器像虚拟机那样有独立的文件系统，进程系统，内存系统，等等一系列，linux宿主机系统采用的办法是：通过隔离容器不让它看到主机的文件系统，进程系统，内存系统，等等一系列。
---mac os和windows运行docker的原理---
通过boot2docker（<a href="http://boot2docker.io/">http://boot2docker.io/</a> ）启动一个虚拟linux kernel，所有的docker容器都跑在这个kernel上。
docker 其实真正想做的事情是把资源隔离的接口标准化（最新的版本里windows的接口也被抽象到了docker自己的体系），严格说它是所有相似资源隔离的一层抽象和搬运工</p>
<p>参考
[开发者必备的 Docker 实践指南](<a href="https://juejin.cn/book/6844733746462064654/section/6844733746562727950%5D">https://juejin.cn/book/6844733746462064654/section/6844733746562727950]</a></p>
<h3 id="1docker简历">1.Docker简历</h3>
<p>使用背景</p>
<p>常见的虚拟机实现中，我们要搭建一套 LAMP 结构的服务，我们通常会建立一个虚拟机，在虚拟机中安装上 Linux 系统，之后分别安装 Apache、MySQL 和 PHP。而在 Docker 里，最佳的实践是分别基于 Apache、MySQL 和 PHP 的镜像建立三个容器，分别运行 Apache、MySQL 和 PHP ，而它们所在的虚拟操作系统也直接共享于宿主机的操作系统。</p>






























<table><thead><tr><th>属性</th><th align="left">Docker</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td align="left">秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td align="left">MB 级</td><td>GB 级</td></tr><tr><td>性能</td><td align="left">接近原生</td><td>较低</td></tr><tr><td>普通机器支撑量</td><td align="left">数百个</td><td>几个</td></tr></tbody></table>
<h4 id="为什么docker这么快">为什么docker这么快</h4>
<ul>
<li>容器技术支持，应用就是容器的方案。容器技术剔除了hypervisior层，又干掉了虚拟操作系统的概念。</li>
<li>基于联合文件系统的底层文件系统支持，容器可以容易和真实系统共享存储资源，带来了存储空间的低消耗。</li>
<li>docker自身就是跨平台的，docker支持在容器中同时运行多种程序，但是这样会降低docker效率。</li>
<li>综上： CI持续集成( Continuous Integration ) 和持续交付 ( Continuous Delivery )。</li>
</ul>
<h3 id="2docker核心组成">2.Docker核心组成</h3>
<h4 id="四大组成对象">四大组成对象。</h4>
<ul>
<li>镜像image</li>
<li>容器Container</li>
<li>网络Network</li>
<li>数据卷Volume</li>
</ul>
<h4 id="镜像">镜像</h4>
<p>镜像可以理解为一个只读文件包，包含了虚拟环境运行最原始文件系统的内容。</p>
<p>Dokcer的创新，利用了AUFS作为底层文件系统实现，通过这种方式，Docker实现增量式镜像结构。</p>
<p>每一次对于镜像的修改，Docker都会铸造一个镜像层，一个镜像其实就是其下层所有的镜像层组成。</p>
<p>所以基于这种结构，Dokcer镜像实质无法修改，只能产生新的镜像，不是更新原有的镜像。</p>
<h4 id="容器核心namepace和group">容器（核心namepace和group）</h4>
<p>容器就是用来隔离虚拟环境基础设施。</p>
<p>镜像可以理解为编程中的类，那么容器可以理解为类的实例。</p>
<p>镜像内存放不可以变化的东西，当用它为基础的容器启动后，容器成为一个活的空间。</p>
<p>一个Dokcer容器必须有三部分：一个Dokcer镜像，一个程序运行环境，一个指令集合</p>
<h4 id="网络cgroup">网络(cgroup)</h4>
<p>网络通讯是最常用的程序之间数据交换方式。</p>
<p>Dokcer中不仅可以对于每一个容器进行网络配置，还可以在容器之间建立虚拟网络，将数个容器包裹其中，同其他的网络环境隔离。</p>
<p>Dokcer能够利用技术，在容器中营造独立域名解析环境，让我们不修改代码和配置的前提下直接迁移容器，Dokcer会为我们完成新的环境网络适配。</p>
<h4 id="数据卷">数据卷</h4>
<p>文件是进行数据交换的资源。一般在虚拟机中，挂载文件是繁琐的，因为序号搞定不同文件系统的兼容性。</p>
<p>但是Dokcer可以不用关心文件系统的挂载，可以通过Dokcer底层的Union file system技术，实现不同目录的数据存放和容器文件共享。</p>
<h4 id="docker-engine">Docker Engine</h4>
<h6 id="容器化的实现">容器化的实现</h6>
<p>实现容器化的工作通过Docker官方维护，DOkcer命名为Dokcer Engine.</p>
<p>其中其实通过各种独立软件包组成，其中最核心的两个部分：docker daemon和dockerCli</p>
<h4 id="docker-daemon和docker-cli">docker daemon和docker CLI</h4>
<p>docker daemon功能：容器管理，应用编排，镜像分发等功能</p>
<p>docker CLI功能：镜像模块，容器模块，数据卷模块，网络模块等</p>
<p>docker daemon通常通过服务的形式，进行静默运行，我们称之为Dokcer服务。</p>
<p>docker daemon管理容器的同时，向外暴露了一套RestAPi，我们可以通过这套接口进行docker daemon操作。（输入命令进行docker daemon管理）</p>
<p>docker daemon和docker CLI组成的正式一个标准C/S(client-Server)结构应用。</p>
<h3 id="3dokcer运行环境搭建">3.Dokcer运行环境搭建</h3>
<p>安装前的准备。</p>
<p>基本概念：</p>
<ul>
<li>社区版 ( CE, Community Edition )：容器基础管理</li>
<li>企业版 ( EE, Enterprise Edition )：增加了容器管理，镜像管理，插件，安全</li>
</ul>
<p>Docker Engine迭代分为稳定版（Stable release）和预览版（Edge Release）</p>
<p>Docker Engine稳定版每三个月更新一次。</p>
<h4 id="dokcer环境依赖版本要求">Dokcer环境依赖版本要求</h4>

























<table><thead><tr><th>操作系统</th><th>支持的系统版本</th></tr></thead><tbody><tr><td>CentOS</td><td>CentOS 7</td></tr><tr><td>Debian</td><td>Debian Wheezy 7.7 (LTS) Debian Jessie 8 (LTS) Debian Stretch 9 Debian Buster 10</td></tr><tr><td>Fedora</td><td>Fedora 26 Fedora 27</td></tr><tr><td>Ubuntu</td><td>Ubuntu Trusty 14.04 (LTS) Ubuntu Xenial 16.04 (LTS) Ubuntu Artful 17.10</td></tr></tbody></table>
<h4 id="linux系统中安装docker">linux系统中安装Docker</h4>
<h6 id="必须是--docker-is-running才能表明docker">必须是： * Docker is running才能表明docker</h6>
<p>注意如果使用windows下的unbutu使用20.4版本。docker正常，unbutu22有docker的running问题。慎用，解决了一天，各种官方方法解决不了unbutu22的报错，个人放弃了最新版本。</p>
<p>Docker本身基于linux核心能力。目前主流的linux系统拥有软件包管理功能，那么细节我们不去关心。</p>
<h4 id="ubuntu">Ubuntu</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span></span>
<span class="line"><span style="color: #c9d1d9">$</span></span>
<span class="line"><span style="color: #c9d1d9">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo apt-get update  //替换成 sudo  apt  update</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo apt-get install docker-ce //sudo apt install docker-ce</span></span>
<span class="line"><span style="color: #c9d1d9">$两种启动docker命令</span></span>
<span class="line"><span style="color: #c9d1d9">第一种</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo systemctl enable docker//注意这个命令了，docker version</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo systemctl start docker</span></span>
<span class="line"><span style="color: #c9d1d9">或是使用下面</span></span>
<span class="line"><span style="color: #c9d1d9">启动服务docker</span></span>
<span class="line"><span style="color: #c9d1d9">sudo service docker restart</span></span>
<span class="line"><span style="color: #c9d1d9"> sudo service docker status   </span></span>
<span class="line"><span style="color: #c9d1d9"> </span></span>
<span class="line"><span style="color: #c9d1d9"> 注意 sudo service docker status   后必须：Docker is running</span></span></code></pre>
<p>但是docker version可以正确打印。但是启动systemctl enable docker不能够使用。</p>
<p>如果不能使用，使用</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">sudo service docker start</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">注意： sudo chmod -R 777 /var/run/docker.sock</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">启动服务docker</span></span>
<span class="line"><span style="color: #c9d1d9">sudo service docker restart</span></span>
<span class="line"><span style="color: #c9d1d9">sudo service docker status   </span></span>
<span class="line"><span style="color: #c9d1d9">必须是： * Docker is running才能表明docker</span></span></code></pre>
<h6 id="解决docker-is-not-runing">解决docker is not runing</h6>
<h4 id="docker正确安装和可用的标记">docker正确安装和可用的标记</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">方式1：</span></span>
<span class="line"><span style="color: #c9d1d9">docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">开启docker Desktop下进入setting,选择TLS</span></span></code></pre>
<p>打开windows桌面端的TLS端口
方法2：</p>
<h4 id="将子系统作为docker-client端连接远程docker-damaen服务">将子系统作为docker client端连接远程docker damaen服务</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">我们知道docker是cs架构的，即分为client端和server端，本地都是通过socket协议通讯的，如果本地client要连接远程的docker服务，则需要在client上导出以下环境变量</span></span>
<span class="line"><span style="color: #c9d1d9">export DOCKER_HOST=tcp://&#x3C;your docker server ip>:2375</span></span>
<span class="line"><span style="color: #c9d1d9">2375是默认的连接端口，当然你可以在服务器端指定其他端口。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">（前提：远程docker server开启了tcp连接，即在 /lib/systemd/system/docker.service 中的ExecStart=/usr/bin/dockerd 一句后面追加tcp访问协议，如下：</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">   ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375</span></span></code></pre>
<h6 id="修改镜像docker源头加快镜像拉取">修改镜像docker源头，加快镜像拉取</h6>
<p>vi /etc/docker/daemon.json</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">{</span></span>
<span class="line"><span style="color: #c9d1d9">    "registry-mirrors": [</span></span>
<span class="line"><span style="color: #c9d1d9">        "https://registry.docker-cn.com"</span></span>
<span class="line"><span style="color: #c9d1d9">    ]</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span></code></pre>
<p>要验证我们配置的镜像源是否生效，我们可以通过 <code>docker info</code> 来查阅当前注册的镜像源列表。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">sudo docker info</span></span>
<span class="line"><span style="color: #c9d1d9">测试拉取</span></span>
<span class="line"><span style="color: #c9d1d9">jdk安装</span></span>
<span class="line"><span style="color: #c9d1d9">docker pull jenkins/jenkins</span></span>
<span class="line"><span style="color: #c9d1d9">//最新的镜像拉取加你：docker pull jenkinsci/blueocean</span></span>
<span class="line"><span style="color: #c9d1d9">Using default tag: latest出现报错</span></span>
<span class="line"><span style="color: #c9d1d9">增加sudo</span></span></code></pre>
<p>####### 配置相关的地址https地址国内进行配置
不然安装初始化后，没办法内容下载更新
可以在jenkins下面的内容：Plugin Manager最下面的内容</p>
<h6 id="注意如果拉去jenkins注意安装jdkjre">注意如果拉去jenkins注意，安装jdk，jre</h6>
<p>查看docker相关信息 docker info</p>
<p>####### 2.1 wsl上安装Jenkins及简单配置（ubuntu系统配置）
在Windows下比较推荐使用wsl的方式安装Jenkins，这样切换到Linux时也会比较熟悉，如果资源等可以的话，更推荐使用docker方式。这里以wsl+Ubuntu简单说明下wsl安装Jenkins，后续的go程序编译也是在wsl上的。</p>
<p>######### 安装jdk、jre
sudo apt install default-jdk default-jre</p>
<p>######### docker安装安装Jenkins
sudo apt update
使用下面的命令进行安装
docker pull jenkins/jenkins</p>
<p>-----或是docker pull jenkinsci/blueocean</p>
<p>docker启动jenkins/jenkins</p>
<ul>
<li>新建一个菜单：home下面，jenkins_home（创建 Jenkins 工作目录，将容器内目录挂载到此目录上，这样我们可以在宿主机上对文件的修改同步到容器内。）
mkdir -p /home/jenkins_home</li>
<li>权限菜单放开</li>
</ul>
<p>chown -R 1000:1000 /home/jenkins_home
或是使用：chmod 777 /home/jenkins_home</p>
<ul>
<li>根据新建的菜单内容，进行的相关的启动命令和说明
最后一个参数是jenkins镜像的名称，倒数第二个参数是想要部署的地址。
docker run -p 8080:8080 -p 50000:50000 -v /home/jenkins_home   jenkins/jenkins</li>
</ul>
<p>补充一个启动解释</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9"># -d 后台方式启动</span></span>
<span class="line"><span style="color: #c9d1d9"># -p 映射端口，宿主机端口:容器内端口</span></span>
<span class="line"><span style="color: #c9d1d9"># -v 挂载卷，将容器Jenkins工作目录/var/jenkins_home挂载到宿主机目录/usr/local/jenkins</span></span>
<span class="line"><span style="color: #c9d1d9"># -name 给容器起个别名</span></span>
<span class="line"><span style="color: #c9d1d9">docker run -d -p 8099:8080 -p 50099:50000 -v /usr/local/jenkins:/var/jenkins_home --name myjenkins jenkinsci/blueocean</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>注意将后面8080的端口映射到前面8080这个上面</p>
<p>此时的jenkins的密码
429815fca1c24890841a4f2f62021dc9</p>
<ul>
<li>默认访问localhost:8080
这里稍后进行配置修改</li>
</ul>
<p>这里假设账号密码：admin账号，密码是123456</p>
<h3 id="windows中使用docker原理">windows中使用Docker原理</h3>
<p>其实 Docker Desktop 的实现逻辑很简单：既然 Windows 和 macOS 中没有 Docker 能够利用的 Linux 环境，那么我们生造一个 Linux 环境就行啦！Docker for Windows 和 Docker for Mac 正是这么实现的</p>
<p>实现这个功能得益于 docker daemon 对外提供的操作过程并不是复杂且领域性强的 IPC 等方式，而是通用的 RESTful Api 的形式。也就是说，Docker Desktop 只要实现 Windows 和 macOS 中的客户端，就能够直接利用 Hypervisor 的网络支持与虚拟 Linux 系统中的 docker daemon 进行通讯，并对它进行控制。</p>
<h3 id="6镜像与容器">6.镜像与容器</h3>
<h4 id="docker镜像">Docker镜像</h4>
<p>镜像包含应用程序和相关依赖的一个基础文件系统。镜像是对于容器运行环境的持久化存储结果。</p>
<p>容器启动的过程中，通过只读的方式用于创建容器的运行方式。</p>
<h4 id="查看镜像">查看镜像</h4>
<p>查看docker daemon中存放和管理了那些镜像，可以看docker images命令。</p>
<h4 id="镜像命令">镜像命令</h4>
<p>docker images命令打印的内容中，两个有关镜像的数据：REPOSITORY和TAG，这两者就是docker对于镜像的命名规范。</p>
<ul>
<li><strong>username</strong>： 主要用于识别上传镜像的不同用户，与 GitHub 中的用户空间类似。</li>
<li><strong>repository</strong>：主要用于识别进行的内容，形成对镜像的表意描述。</li>
<li><strong>tag</strong>：主要用户表示镜像的版本，方便区分进行内容的不同细节:<code>redis:3.2</code> 和 <code>redis:4.0</code>。因为前面说过导出镜像重新修改后，会重新生成一个。</li>
</ul>
<h4 id="容器的生命周期">容器的生命周期</h4>
<p>我们只需要关系几个核心的容器状态。</p>
<p><strong>Created</strong>、<strong>Running</strong>、<strong>Paused</strong>、<strong>Stopped</strong>、<strong>Deleted</strong>。</p>
<p>在这几种状态中，Running 是最为关键的状态，在这种状态中的容器，就是真正正在运行的容器了。</p>
<h4 id="主进程">主进程</h4>
<p>当容器中的主进程主动关闭时 ( 正常结束或出错停止 )，也会让容器随之停止</p>
<p>主进程作为容器的主进程。</p>
<p>虽然在 Docker 中我们也能够实现在同一个容器中运行多个不同类型的程序，但这么做的话，Docker 就无法跟踪不同应用的生命周期，有可能造成应用的非正常关闭，进而影响系统、数据的稳定性。</p>
<h4 id="写时复制机制">写时复制机制</h4>
<p>采用写时复制机制来设计的 Docker，既保证了镜像在生成为容器时，以及容器在运行过程中，不会对自身造成修改。又借助剔除常见虚拟化在初始化时需要从镜像中拷贝整个文件系统的过程，大幅提高了容器的创建和启动速度。可以说，Docker 容器能够实现秒级启动速度，写时复制机制在其中发挥了举足轻重的作用。</p>
<h3 id="7从镜像仓库获得镜像">7.从镜像仓库获得镜像</h3>
<h4 id="镜像仓库">镜像仓库</h4>
<p>如果说我们把镜像的结构用 Git 项目的结构做类比，那么镜像仓库就可以看似 GitLab、GitHub 等的托管平台，只不过 Docker 的镜像仓库托管的不是代码项目，而是镜像。</p>
<p>存储镜像并不是镜像仓库最值得炫耀的功能，其最大的作用是实现了 Docker 镜像的分发。</p>
<h4 id="获取镜像">获取镜像</h4>
<p>docker pull或是sudo docker pull</p>
<p>注意docker如果发现本地已经存在相同的镜像，略过拉取，直接使用本地。</p>
<p><code>docker images</code> 命令看到它们</p>
<h4 id="dokcer-hub镜像仓库">Dokcer Hub镜像仓库</h4>
<p>Docker Hub是Docker是官方中央镜像仓库，除了基础镜像功能，还支持权限管理，构建钩子和自动构建机制。</p>
<p>Docker Hub 的地址是：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fhub.docker.com%2F">hub.docker.com/</a></p>
<p>类似于github可以上传和共享镜像。</p>
<h4 id="docker-hub搜索镜像">Docker Hub搜索镜像</h4>
<p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p>
<ul>
<li><strong>OFFICIAL</strong> 代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高</li>
<li><strong>STARS</strong> 代表镜像的关注人数，这类似 GitHub 的 Stars，可以理解为热度</li>
<li><strong>PULLS</strong> 代表镜像被拉取的次数，基本上能够表示镜像被使用的频度</li>
</ul>
<p>使用命令，搜索本地查看某一个镜像</p>
<p>sudo docker search ubuntu</p>
<h4 id="管理镜像">管理镜像</h4>
<p>docker images可以看到镜像基本信息。但是如果看到更加完整信息，</p>
<p>命令：sudo docker inspect  redis1.1页支持通过容器ID查看</p>
<h4 id="docker的参数识别">Docker的参数识别</h4>
<p>镜像ID是64个字符，但是docker images后，只有12个字符。</p>
<p>其实docker本身做了匹配，根据当前的镜像tag中的内容或是id进行查找。</p>
<h4 id="删除镜像">删除镜像</h4>
<p>sudo docker rmi ubuntu:latest</p>
<p>使用镜像名称或是镜像id</p>
<h3 id="8运行和管理容器">8.运行和管理容器</h3>
<h4 id="容器的创建和启动">容器的创建和启动。</h4>
<h6 id="创建容器">创建容器</h6>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker create nginx:1.12</span></span>
<span class="line"><span style="color: #c9d1d9">34f277e22be252b51d204acbb32ce21181df86520de0c337a835de6932ca06c3</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">使用容器需要给容器起名字</span></span>
<span class="line"><span style="color: #c9d1d9"> sudo docker create --name nginx nginx:1.12</span></span>
<span class="line"><span style="color: #c9d1d9"> </span></span></code></pre>
<h6 id="启动容器">启动容器</h6>
<p>sudo docker start nginx</p>
<p>根据起的名字进行运行。</p>
<h6 id="创建和启动进行合并的docker命令">创建和启动进行合并的docker命令</h6>
<p>sudo docker run —name nginx -d nginx:1.12</p>
<p>docker  run等于创建容器和启动容器。</p>
<h6 id="管理容器">管理容器</h6>
<p>docker  ps</p>
<p>罗列当前的容器。</p>
<p>如果看容器状态：docker ps -a</p>
<h6 id="停止和删除容器">停止和删除容器</h6>
<p>sudo  docker stop  nginx</p>
<p>sudo  docker rm nginx ;//默认情况不可以删除，-f或是—force</p>
<h6 id="进入容器内部">进入容器内部</h6>
<p>高级阶段学习</p>
<p>只需要了解命令</p>
<p>sudo docker exec nginx more /etc/hostname</p>
<h3 id="9为容器配置网络">9.为容器配置网络</h3>
<h4 id="容器网络">容器网络</h4>
<p>Dokcer的网络，存在三个核心的概念，</p>
<ul>
<li>沙盒sandbox:提供容器虚拟网络栈，提供ip路由表，防火墙 等</li>
<li>网络network：docker内部虚拟网络，实现容器内部通讯</li>
<li>端点endponit：行程封闭环境的出入口管理，进行数据传输的管理</li>
</ul>
<h4 id="容器docker的网络实现">容器Docker的网络实现</h4>
<p>容器网络模型为容器引擎提供了一套标准的网络对接范式，而在 Docker 中，实现这套范式的是 Docker 所封装的 libnetwork 模块</p>
<p>目前 Docker 官方为我们提供了五种 Docker 网络驱动，分别是：<strong>Bridge Driver</strong>、<strong>Host Driver</strong>、<strong>Overlay Driver</strong>、<strong>MacLan Driver</strong>、<strong>None Driver</strong>。</p>
<p>其中，Bridge 网络是 Docker 容器的默认网络驱动，简而言之其就是通过网桥来实现网络通讯 ( 网桥网络的实现可以基于硬件，也可以基于软件 )。而 Overlay 网络是借助 Docker 集群模块 Docker Swarm 来搭建的跨 Docker Daemon 网络，我们可以通过它搭建跨物理主机的虚拟网络，进而让不同物理机中运行的容器感知不到多个物理机的存在。</p>
<h4 id="容器互联重点打通nigixh和web应用通信">！！！容器互联（重点：打通nigixH和web应用通信）</h4>
<p><strong>docker已经不推荐用link了，用自定义网络来实现容器互联</strong></p>
<p>为什么我配置了docker/nginx 连接docker/flask-app 也进行端口映射 外面还是访问不到里面的docker 服务？</p>
<p>运行容器时添加 —net host 参数，docker run —net host</p>
<p>####### 还有一个根本好办法：点到后面看了下，可以用Docker Compose</p>
<p>如果要设置5个容器之间网络互通，有什么好的方式呢？</p>
<p>要让一个容器连接到另外一个容器，我们可以在容器通过 <code>docker create</code> 或 <code>docker run</code> 创建时通过 <code>--link</code> 选项进行配置。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=yes mysql</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name webapp --link mysql webapp:latest</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>如何在 Web 应用中连接到 MySQL 数据库呢？Docker 为容器间连接提供了一种非常友好的方式，我们只需要将容器的网络命名填入到连接地址中，就可以访问需要连接的容器了。</p>
<h4 id="暴露端口">！！！暴露端口</h4>
<p>docker ps查看port部分内容</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker ps</span></span>
<span class="line"><span style="color: #c9d1d9">其中PORTS</span></span>
<span class="line"><span style="color: #c9d1d9"> 3306/tcp, 33060/tcp</span></span>
<span class="line"><span style="color: #c9d1d9">表示可以通过这两个端口连接。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>需要注意的是，虽然容器间的网络打通了，但并不意味着我们可以任意访问被连接容器中的任何服务。Docker 为容器网络增加了一套安全机制，只有容器自身允许的端口，才能被其他容器所访问。</p>
<p>这个容器自我标记端口可被访问的过程，我们通常称为暴露端口。我们在 <code>docker ps</code> 的结果中可以看到容器暴露给其他容器访问的端口。</p>
<p>端口的暴露可以通过 Docker 镜像进行定义，也可以在容器创建时进行定义。在容器创建时进行定义的方法是借助 <code>--expose</code> 这个选项。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=yes --expose 13306 --expose 23306 mysql:5.7</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h6 id="通过别名连接">通过别名连接</h6>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">sudo docker run -d --name webapp --link mysql:database webapp:latest</span></span></code></pre>
<p>在这里，我们使用 <code>--link &#x3C;name>:&#x3C;alias></code> 的形式</p>
<h6 id="管理网络">管理网络</h6>
<p>我们刚才之所以能够把 webapp 容器连接到 mysql 容器上，其原因是两者都处于 bridge 这个网络上。</p>
<h6 id="创建网络和指定网络加入容器">！！！创建网络和指定网络加入容器</h6>
<p>在 Docker 里，我们也能够创建网络，形成自己定义虚拟子网的目的。</p>
<p>docker CLI 里与网络相关的命令都以 <code>docker network</code> 开头，其中创建网络的命令是 <code>docker network create</code>。</p>
<ul>
<li>查看已经存在的网络：docker  network ls</li>
</ul>
<p>通过 <code>docker network ls</code> 或是 <code>docker network list</code> 可以查看 Docker 中已经存在的网络</p>
<p>我们创建新的容器时候，可以通过增加参数—network bridge加入</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=yes --network bridge mysql:5.7</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">将mysql加入--network bridge网络中</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h6 id="端口映射">！！！端口映射</h6>
<p>我们需要容器外可以通过网络访问容器中的应用。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">为什么我配置了docker/nginx 连接docker/flask-app 也进行端口映射 外面还是访问不到里面的docker 服务？</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">运行容器时添加 --net host 参数，docker run --net host</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>比如：我们提高了web服务，那么我们需要一种方式可以访问运行在容器中的web应用。</p>
<p>要映射端口，我们可以在创建容器时使用 <code>-p</code> 或者是 <code>--publish</code> 选项。</p>
<p>####### 还有一个根本好办法：点到后面看了下，可以用Docker Compose</p>
<p>如果要设置5个容器之间网络互通，有什么好的方式呢？</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">容器的 80 端口映射到宿主操作系统的 8080 端口，传入 -p 8080:80 即可。</span></span>
<span class="line"><span style="color: #c9d1d9">使用端口映射选项的格式是 -p &#x3C;ip>:&#x3C;host-port>:&#x3C;container-port>，其中 ip 是宿主操作系统的监听 ip，可以用来控制监听的网卡，默认为 0.0.0.0，也就是监听所有网卡</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name nginx -p 80:80 -p 443:443 nginx:1.12</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>如果我们使用 Docker for Windows 或 Docker for Mac，这个端口映射的操作程序会自动帮助我们完成，所以我们不需要做任何额外的事情，就能够直接使用 Windows 或 macOS 的端口访问容器端口了。</p>
<h3 id="10管理和存储数据">10.管理和存储数据</h3>
<h4 id="数据管理方式的实现">数据管理方式的实现。</h4>
<p>容器运行文件处于沙盒环境，和外界隔离了，如何与外界进行交换。</p>
<ul>
<li>沙盒文件系统是跟随容器生命周期所创建和移除的，数据无法直接被持久化存储。</li>
<li>由于容器隔离，我们很难从容器外部获得或操作容器内部文件中的数据。</li>
</ul>
<p>Docker 很好的解决了这些问题，这主要还是归功于 Docker 容器文件系统是基于 UnionFS。由于 UnionFS 支持挂载不同类型的文件系统到统一的目录结构中，所以我们只需要将宿主操作系统中，文件系统里的文件或目录挂载到容器中，便能够让容器内外共享这个文件。</p>
<h4 id="挂载方式">挂载方式：</h4>
<p>Docker三种挂载方式：<strong>Bind Mount</strong>、<strong>Volume</strong> 和 <strong>Tmpfs Mount</strong>。</p>
<ul>
<li><strong>Bind Mount</strong> 能够直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，通过指定容器外的路径和容器内的路径，就可以形成挂载映射关系，在容器内外对文件的读写，都是相互可见的。</li>
<li><strong>Volume</strong> 数据卷的本质其实依然是宿主操作系统上的一个目录，只不过这个目录存放在 Docker 内部，接受 Docker 的管理。</li>
<li><strong>Tmpfs Mount</strong> 它主要利用内存来存储数据</li>
</ul>
<h4 id="挂载文件到容器">挂载文件到容器</h4>
<p>—volume或是-v两个参数，可以挂载。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name nginx -v /webapp/html:/usr/share/nginx/html nginx:1.12</span></span></code></pre>
<h6 id="注意挂载数据卷">注意挂载数据卷</h6>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">由于 -v 选项既承载了 Bind Mount 的定义，又参与了 Volume 的定义，所以其传参方式需要特别留意。前面提到了，-v 在定义绑定挂载时必须使用绝对路径，其目的主要是为了避免与数据卷挂载中命名这种形式的冲突。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker run -d --name webapp -v appdata:/webapp/storage webapp:latest</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>我们使用 <code>-v</code> 选项挂载数据卷时，如果数据卷不存在，Docker 会为我们自动创建和分配宿主操作系统的目录，而如果同名数据卷已经存在，则会直接引用</p>
<p><code>docker volume create</code> 我们可以不依赖于容器独立创建数据卷。</p>
<p>列出当前已创建的数据卷。</p>
<p>$ sudo docker volume create appdata</p>
<p>直接通过 <code>docker volume rm</code> 来删除指定的数据卷</p>
<h3 id="11保存和共享镜像">11.保存和共享镜像</h3>
<p>sudo docker commit -m “Upgrade” webapp webapp：2.0</p>
<h4 id="提交容器更新">提交容器更新</h4>
<p>镜像的结构很像代码仓库里的修改记录，而记录容器修改的过程又像是在提交代码，</p>
<p>$ sudo docker commit webapp</p>
<h4 id="为镜像命名">为镜像命名</h4>
<p>注意每一个镜像名称：当前的repository仓库和tag合集</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">docker tag  jenkins/jenkins:latest jenkins</span></span>
<span class="line"><span style="color: #c9d1d9">将一个jenkins/jenkins的image和tag为latest的镜像命名为jenkins，这样开启方便。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>导入和迁移镜像</p>
<p>暂时不太实用命令。</p>
<h3 id="12dockerfile创建镜像">12.Dockerfile创建镜像？？</h3>
<p>通过docker特有的镜像定义文件，Dockerfile可以体验秒级迁移的乐趣。</p>
<h4 id="dockerfile">Dockerfile</h4>
<p>Dockerfile 中，包含了构建镜像过程中需要执行的命令和其他操作.</p>
<p>Dockerfile 的内容很简单，主要以两种形式呈现，一种是注释行，另一种是指令行。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9"># Comment</span></span>
<span class="line"><span style="color: #c9d1d9">INSTRUCTION arguments</span></span></code></pre>
<h4 id="环境搭建与镜像构建">环境搭建与镜像构建</h4>
<p>Dockerfile 就很像这样一个环境搭建手册，因为其中包含的就是一个构建容器的过程。</p>
<ul>
<li>Dockerfile 的体积远小于镜像包，更容易进行快速迁移和部署。</li>
<li>环境构建流程记录了 Dockerfile 中，能够直观的看到镜像构建的顺序和逻辑。</li>
<li>使用 Dockerfile 来构建镜像能够更轻松的实现自动部署等自动化流程。</li>
<li>在修改环境搭建细节时，修改 Dockerfile 文件要比从新提交镜像来的轻松、简单</li>
</ul>
<p>在实际使用中，我们也很少会选择容器提交这种方法来构建镜像，而是几乎都采用 Dockerfile 来制作镜像。</p>
<p>Docker实用的开发者的必备是Dockerfile文件能力。</p>
<h4 id="常见-dockerfile-指令">常见 Dockerfile 指令</h4>
<h6 id="from">FROM</h6>
<p>通常来说，我们不会从零开始搭建一个镜像，而是会选择一个已经存在的镜像作为我们新镜像的基础，这种方式能够大幅减少我们的时间</p>
<h6 id="run">RUN</h6>
<p>RUN 指令就是用于向控制台发送命令的指令</p>
<h6 id="entrypoint-和-cmd">ENTRYPOINT 和 CMD</h6>
<p>基于镜像启动的容器，在容器启动时会根据镜像所定义的一条命令来启动容器中进程号为 1 的进程。</p>
<h6 id="copy-和-add">COPY 和 ADD</h6>
<p>在制作新的镜像的时候，我们可能需要将一些软件配置、程序代码、执行脚本等直接导入到镜像内的文件系统里，使用 COPY 或 ADD 指令能够帮助我们直接从宿主机的文件系统里拷贝内容到镜像里的文件系统中。</p>
<p><a href="https://blog.csdn.net/u013258415/article/details/80022224">【docker】CMD ENTRYPOINT 区别 终极解读！_强大的石头的博客-CSDN博客</a></p>
<p>一个构建案例成功</p>
<p><a href="https://www.cnblogs.com/jsonhc/p/7767669.html">docker之Dockerfile实践 - wadeson - 博客园 (cnblogs.com)</a></p>
<h4 id="构建镜像">构建镜像</h4>
<p><a href="https://yeasy.gitbook.io/docker_practice/image/build">使用 Dockerfile 定制镜像 - Docker — 从入门到实践 (gitbook.io)</a></p>
<p>编写好Dockerfile后，构建</p>
<p>sudo docker build ./webapp</p>
<p>docker build ./webapp 将路径文件夹 ./webapp 作为构建镜像的环境目录</p>
<p>指定Dockerfile目录</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">`-f` 选项单独给出 Dockerfile 文件的路径</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker build -t webapp:latest -f ./webapp/a.Dockerfile ./webapp</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h3 id="13dockerfile的使用技巧">13.Dockerfile的使用技巧</h3>
<h4 id="构建中使用变量">构建中使用变量</h4>
<p>我们希望通过参数变量控制 Dockerfile 中某个程序的版本，在构建时安装我们指定版本的软件，我们可以通过 ARG 定义的参数作为占位符，替换版本定义的部分。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">FROM debian:stretch-slim</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">### ......</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">ARG TOMCAT_MAJOR</span></span>
<span class="line"><span style="color: #c9d1d9">ARG TOMCAT_VERSION</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">如果我们需要通过这个 Dockerfile 文件构建 Tomcat 镜像，我们可以在构建时通过 docker build 的 --build-arg 选项来设置参数变量</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker build --build-arg TOMCAT_MAJOR=8 --build-arg TOMCAT_VERSION=8.0.53 -t tomcat:8.0 ./tomcat</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="环境变量">环境变量</h4>
<p>环境变量不是通过docker构建指令传入，而是通过Dockerfile编写的。</p>
<p>我们需要修改环境变量，在Dockerfile中编写</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">FROM debian:stretch-slim</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">### ......</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">ENV TOMCAT_MAJOR 8</span></span>
<span class="line"><span style="color: #c9d1d9">ENV TOMCAT_VERSION 8.0.53</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>如何查找镜像的dockerfile文件。</p>
<p><a href="https://juejin.cn/book/6844733746462064654/section/6844733746554355720">开发者必备的 Docker 实践指南 - 有明 - 掘金课程 (juejin.cn)</a></p>
<h6 id="临摹案例">临摹案例</h6>
<p>进入中央仓库docker hub或是</p>
<h3 id="14常见的docker-hub的镜像">14.常见的docker hub的镜像</h3>
<h4 id="选择镜像和程序版本">选择镜像和程序版本</h4>
<p>在 Docker 里，Alpine 系统的镜像到底有多小，我们不妨来与其他系统镜像做一个比较。</p>

















<table><thead><tr><th>镜像标签</th><th>占用空间</th></tr></thead><tbody><tr><td>python:3.6-alpine</td><td>74.2 MB</td></tr><tr><td>python:3.6-jessie</td><td>697 MB</td></tr></tbody></table>
<p>由于基于 Alpine 系统建立的软件镜像远远小于基于其他系统的软件镜像，它在网络传输上的优势尤为明显。如果我们选择这类的镜像，不但可以节约网络传输的时间，也能减少镜像对硬盘空间的占用。</p>
<p>当然，有优点也会有缺点，Alpine 镜像的缺点就在于它实在过于精简，以至于麻雀虽小，也无法做到五脏俱全了</p>
<h3 id="15使用docker-compose管理容器">15.使用Docker Compose管理容器</h3>
<h4 id="解决容器管理的问题">解决容器管理的问题</h4>
<p>如果简单的内容</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">就拿最简单的例子来说吧，如果我们要为我们的应用容器准备一个 MySQL 容器和一个 Redis 容器，那么在每次启动时，我们先要将 MySQL 容器和 Redis 容器启动起来，再将应用容器运行起来。这其中还不要忘了在创建应用容器时将容器网络连接到 MySQL 容器和 Redis 容器上，以便应用连接上它们并进行数据交换。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="docker-compose">Docker Compose</h4>
<p>针对这种情况，我们就不得不引出在我们开发中最常使用的多容器定义和运行软件，也就是 Docker Compose 了。</p>
<p>如果说 Dockerfile 是将容器内运行环境的搭建固化下来，</p>
<p>那么 Docker Compose 我们就可以理解为将多个容器运行的方式和配置固化下来。</p>
<h4 id="linux安装-docker-composedocker-compose安装">linux安装 Docker Compose:docker-compose安装</h4>
<p>Docker Compose 是一个由 Python 编写的软件，在拥有 Python 运行环境的机器上，我们可以直接运行它，不需要其它的操作。</p>
<p>如果下载过慢，可以到网上下载 ，然后上传到/usr/local/bin/目录</p>
<p>但是文件下载哪一种格式，需要注意以下，不然罗马</p>
<p>还有一种，告诉下载compose</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">-高速安装命令</span></span>
<span class="line"><span style="color: #c9d1d9">curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">-将可执行权限应用于二进制文件：</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">sudo chmod +x /usr/local/bin/docker-compose</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">-创建软链接</span></span>
<span class="line"><span style="color: #c9d1d9">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span></span>
<span class="line"><span style="color: #c9d1d9">-测试是否成功</span></span>
<span class="line"><span style="color: #c9d1d9">docker-compose --version</span></span>
<span class="line"><span style="color: #c9d1d9">cker-compose version 1.24.1, build 4667896b</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>修改读写文件权限</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9"> chmod +x /usr/local/bin/docker-compose</span></span></code></pre>
<h4 id="在-windows-和-macos-中的-docker-compose">在 Windows 和 macOS 中的 Docker Compose</h4>
<p>在我们更常用于开发的 Windows 和 macOS 中，使用 Docker Compose 会来得更加方便。不论你是使用 Docker for Win 还是 Docker for Mac，亦或是 Docker Toolbox 来搭建 Docker 运行环境，你都可以直接使用 <code>docker-compose</code> 这个命令。这三款软件都已经将 Docker Compose 内置在其中，供我们使用。</p>
<h4 id="docker-compose-的基本使用逻辑">Docker Compose 的基本使用逻辑</h4>
<p>如果将使用 Docker Compose 的步骤简化来说，可以分成三步。</p>
<ol>
<li>如果需要的话，编写容器所需镜像的 Dockerfile；( 也可以使用现有的镜像 )</li>
<li>编写用于配置容器的 docker-compose.yml；</li>
<li>使用 docker-compose 命令启动应用。</li>
</ol>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">简单docker-compose配置文件</span></span>
<span class="line"><span style="color: #c9d1d9">version: '3'</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">services:</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">  webapp:</span></span>
<span class="line"><span style="color: #c9d1d9">    build: ./image/webapp</span></span>
<span class="line"><span style="color: #c9d1d9">    ports:</span></span>
<span class="line"><span style="color: #c9d1d9">      - "5000:5000"</span></span>
<span class="line"><span style="color: #c9d1d9">    volumes:</span></span>
<span class="line"><span style="color: #c9d1d9">      - ./code:/code</span></span>
<span class="line"><span style="color: #c9d1d9">      - logvolume:/var/log</span></span>
<span class="line"><span style="color: #c9d1d9">    links:</span></span>
<span class="line"><span style="color: #c9d1d9">      - mysql</span></span>
<span class="line"><span style="color: #c9d1d9">      - redis</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">  redis:</span></span>
<span class="line"><span style="color: #c9d1d9">    image: redis:3.2</span></span>
<span class="line"><span style="color: #c9d1d9">  </span></span>
<span class="line"><span style="color: #c9d1d9">  mysql:</span></span>
<span class="line"><span style="color: #c9d1d9">    image: mysql:5.7</span></span>
<span class="line"><span style="color: #c9d1d9">    environment:</span></span>
<span class="line"><span style="color: #c9d1d9">      - MYSQL_ROOT_PASSWORD=my-secret-pw</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">volumes:</span></span>
<span class="line"><span style="color: #c9d1d9">  logvolume: {}</span></span>
<span class="line"><span style="color: #c9d1d9">  </span></span>
<span class="line"><span style="color: #c9d1d9">  </span></span>
<span class="line"><span style="color: #c9d1d9">说明文件学习</span></span>
<span class="line"><span style="color: #c9d1d9">首先是 version 这个配置，这代表我们定义的 docker-compose.yml 文件内容所采用的版本</span></span>
<span class="line"><span style="color: #c9d1d9"> services 这块，这是整个 docker-compose.yml 的核心部分，其定义了容器的各项细节。</span></span>
<span class="line"><span style="color: #c9d1d9"> </span></span></code></pre>
<h6 id="启动和停止">启动和停止</h6>
<p>对于开发来说，最常使用的 Docker Compose 命令就是 <code>docker-compose up</code> 和 <code>docker-compose down</code> 了。</p>
<p><code>docker-compose up</code> 和 <code>docker-compose down</code> 了。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">docker-compose up` 命令类似于 Docker Engine 中的 `docker run</span></span></code></pre>
<p>后台运行命令</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker-compose up -d</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker-compose -f ./compose/docker-compose.yml -p myapp up -d</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">但是，这里需要有yml文件。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h6 id="容器命令">容器命令</h6>
<p><strong>docker-compose前提是有yml文件</strong></p>
<p>除了启动和停止命令外，Docker Compose 还为我们提供了很多直接操作服务的命令。</p>
<p>如果我们直接使用 <code>docker logs</code> 就需要先找到容器的名字，这显然有些麻烦了。我们可以直接使用 <code>docker-compose logs</code> 命令来完成这项工作。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">sudo docker-compose logs nginx</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>简单独立命令：操作前提是有yml文件</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">$ sudo docker-compose create webapp</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker-compose start webapp</span></span>
<span class="line"><span style="color: #c9d1d9">$ sudo docker-compose stop webapp</span></span></code></pre>
<h4 id="注意开机启动wsl配置">注意开机启动WSL配置</h4>
<p>docker run -p 8080:8080 -p 50000:50000 -v /home/jenkins_home   jenkins</p>
<h3 id="16常用的-docker-compose-配置项">16.！！！常用的 Docker Compose 配置项</h3>
<p>dockerfile和dockercompose一样，都是配置docker的学习必须。</p>
<h4 id="首先">首先</h4>
<ol>
<li>创建一个项目目录：</li>
</ol>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">mkdir my_app</span></span>
<span class="line"><span style="color: #c9d1d9">cd my_app</span></span></code></pre>
<ol>
<li>打开你的文本编辑器，创建一个名为<code>docker-compose.yml</code>的文件，放在项目目录下：</li>
</ol>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">vim docker-compose.yml</span></span></code></pre>
<ol>
<li>粘贴下面的内容：</li>
</ol>
<p>但是项目里面有真是的文件内容</p>
<h3 id="17编写-docker-compose-项目">17.编写 Docker Compose 项目</h3>
<h4 id="设置项目的目录结构">设置项目的目录结构。</h4>
<p>我们要准备四个容器分别来运行它们。而为了更好地管理这四个容器所组成的环境，我们这里还会使用到 Docker Compose。</p>
<p>\wsl.localhost\Ubuntu\root</p>
<p>这个下面个人创建不同的文件夹进行设置</p>
<ul>
<li>第一类是 Docker 定义目录，也就是 compose 这个目录。在这个目录里，包含了 docker-compose.yml 这个用于定义 Docker Compose 项目的配置文件。此外，还包含了我们用于构建自定义镜像的内容。</li>
<li>第二类是程序文件目录，在这个项目里是 mysql、nginx、phpfpm、redis 这四个目录。这些目录分别对应着 Docker Compose 中定义的服务，在其中主要存放对应程序的配置，产生的数据或日志等内容。</li>
<li>第三类是代码目录，在这个项目中就是存放 Web 程序的 website 目录。我们将代码统一放在这个目录中，方便在容器中挂载。</li>
<li>第四类是工具命令目录，这里指 bin 这个目录。我们在这里存放一些自己编写的命令脚本，我们通过这些脚本可以更简洁地操作整个项目。</li>
</ul>
<p>如下</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">├── bin ---存放工具命令</span></span>
<span class="line"><span style="color: #c9d1d9">├── compose --存放定义dockercompose的项目配置文件</span></span>
<span class="line"><span style="color: #c9d1d9">├── nginx ---定义一些nginx服务</span></span>
<span class="line"><span style="color: #c9d1d9">│   ├── confi.d</span></span>
<span class="line"><span style="color: #c9d1d9">│   │   └── www.conf</span></span>
<span class="line"><span style="color: #c9d1d9">│   └── nginx.conf</span></span>
<span class="line"><span style="color: #c9d1d9">└── website---存放web的项目代码</span></span></code></pre>
<p>这里用个人之前的项目代码</p>
<p><a href="https://gitee.com/nyhxiaoning/docker-common.git">https://gitee.com/nyhxiaoning/docker-common.git</a></p>
<p>这个文件里面没有自动启动compose的命令，这里增加bin文件sh文件</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">启动运行简单：./start-compose.sh</span></span>
<span class="line"><span style="color: #c9d1d9">但是注意需要给一个权限：chmod u+x start-compose.sh</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>也有作者的相关练习代码链接记录：
<a href="https://github.com/nyhxiaoning/docker-book-for-developer-samples.git">https://github.com/nyhxiaoning/docker-book-for-developer-samples.git</a></p>
<p>注意引入的镜像尽量是 <strong>image</strong>: nginx:alpine乐死alpine这样精简。</p>
<p>直接复制一个项目例如：docker-nginx后，</p>
<p>然后，利用：sudo docker-compose up -d    后台启动这个。</p>
	</section>
	<nav class="block sm:hidden astro-J75B3YUS">
		<h2 class="heading astro-BYIKQF6W">More</h2>
<ul class="astro-BYIKQF6W">
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a class="edit-on-github astro-BYIKQF6W" href="https://github.com/nyhxiaoning/nyhxiaoning.github.io/blob/master/src/content/docs/en/15%E5%B7%A5%E5%85%B7%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/004docker%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0.md" target="_blank">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="pen" class="svg-inline--fa fa-pen fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Edit this page</span>
				</a>
			</li>
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a href="https://astro.build/chat" target="_blank" class="astro-BYIKQF6W">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="comment-alt" class="svg-inline--fa fa-comment-alt fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 9.8 11.2 15.5 19.1 9.7L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Join our community</span>
				</a>
			</li>
</ul>
<div style="margin: 2rem 0; text-align: center;" class="astro-BYIKQF6W">
	<script>(self.Astro=self.Astro||{}).visible=(s,c,n)=>{const r=async()=>{await(await s())()};let i=new IntersectionObserver(e=>{for(const t of e)if(!!t.isIntersecting){i.disconnect(),r();break}});for(let e=0;e<n.children.length;e++){const t=n.children[e];i.observe(t)}},window.dispatchEvent(new Event("astro:visible"));</script><astro-island uid="Z25Qg0T" component-url="/_astro/ThemeToggleButton.90e627d1.js" component-export="default" renderer-url="/_astro/client.15ddb572.js" props="{&quot;class&quot;:[0,&quot;astro-BYIKQF6W&quot;]}" ssr="" client="visible" opts="{&quot;name&quot;:&quot;ThemeToggleButton&quot;,&quot;value&quot;:true}" await-children=""><div class="theme-toggle"><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clipRule="evenodd"></path></svg><input type="radio" name="theme-toggle" value="light" title="Use light theme" aria-label="Use light theme" /></label><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg><input type="radio" name="theme-toggle" value="dark" title="Use dark theme" aria-label="Use dark theme" /></label></div></astro-island>
</div>
	</nav>
</article>
			</div>
			<aside id="grid-right" class="grid-sidebar astro-OUAMJN2I" title="Table of Contents">
				<nav class="sidebar-nav astro-ROIVMLUZ" aria-labelledby="grid-right">
	<div class="sidebar-nav-inner astro-ROIVMLUZ">
		<astro-island uid="252Gx1" component-url="/_astro/TableOfContents.a1e7e9c9.js" component-export="default" renderer-url="/_astro/client.15ddb572.js" props="{&quot;headings&quot;:[1,&quot;[[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;dockerjeninsgitlab部署记录\&quot;],\&quot;text\&quot;:[0,\&quot;docker+jenins+gitlab部署记录\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;1第一步linux系统部署文件下面放置一个docker-composeyml文件\&quot;],\&quot;text\&quot;:[0,\&quot;（1）第一步：linux系统部署文件下面放置一个docker-compose.yml文件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;一步一步来对于地址docker-nginx\&quot;],\&quot;text\&quot;:[0,\&quot;一步一步来：对于地址~/docker-nginx\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;docker学习\&quot;],\&quot;text\&quot;:[0,\&quot;docker学习\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;1docker简历\&quot;],\&quot;text\&quot;:[0,\&quot;1.Docker简历\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;为什么docker这么快\&quot;],\&quot;text\&quot;:[0,\&quot;为什么docker这么快\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;2docker核心组成\&quot;],\&quot;text\&quot;:[0,\&quot;2.Docker核心组成\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;四大组成对象\&quot;],\&quot;text\&quot;:[0,\&quot;四大组成对象。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;镜像\&quot;],\&quot;text\&quot;:[0,\&quot;镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器核心namepace和group\&quot;],\&quot;text\&quot;:[0,\&quot;容器（核心namepace和group）\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;网络cgroup\&quot;],\&quot;text\&quot;:[0,\&quot;网络(cgroup)\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;数据卷\&quot;],\&quot;text\&quot;:[0,\&quot;数据卷\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-engine\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Engine\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;容器化的实现\&quot;],\&quot;text\&quot;:[0,\&quot;容器化的实现\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-daemon和docker-cli\&quot;],\&quot;text\&quot;:[0,\&quot;docker daemon和docker CLI\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;3dokcer运行环境搭建\&quot;],\&quot;text\&quot;:[0,\&quot;3.Dokcer运行环境搭建\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;dokcer环境依赖版本要求\&quot;],\&quot;text\&quot;:[0,\&quot;Dokcer环境依赖版本要求\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;linux系统中安装docker\&quot;],\&quot;text\&quot;:[0,\&quot;linux系统中安装Docker\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;必须是--docker-is-running才能表明docker\&quot;],\&quot;text\&quot;:[0,\&quot;必须是： * Docker is running才能表明docker\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;ubuntu\&quot;],\&quot;text\&quot;:[0,\&quot;Ubuntu\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;解决docker-is-not-runing\&quot;],\&quot;text\&quot;:[0,\&quot;解决docker is not runing\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker正确安装和可用的标记\&quot;],\&quot;text\&quot;:[0,\&quot;docker正确安装和可用的标记\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;将子系统作为docker-client端连接远程docker-damaen服务\&quot;],\&quot;text\&quot;:[0,\&quot;将子系统作为docker client端连接远程docker damaen服务\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;修改镜像docker源头加快镜像拉取\&quot;],\&quot;text\&quot;:[0,\&quot;修改镜像docker源头，加快镜像拉取\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;注意如果拉去jenkins注意安装jdkjre\&quot;],\&quot;text\&quot;:[0,\&quot;注意如果拉去jenkins注意，安装jdk，jre\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;windows中使用docker原理\&quot;],\&quot;text\&quot;:[0,\&quot;windows中使用Docker原理\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;6镜像与容器\&quot;],\&quot;text\&quot;:[0,\&quot;6.镜像与容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker镜像\&quot;],\&quot;text\&quot;:[0,\&quot;Docker镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;查看镜像\&quot;],\&quot;text\&quot;:[0,\&quot;查看镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;镜像命令\&quot;],\&quot;text\&quot;:[0,\&quot;镜像命令\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器的生命周期\&quot;],\&quot;text\&quot;:[0,\&quot;容器的生命周期\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;主进程\&quot;],\&quot;text\&quot;:[0,\&quot;主进程\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;写时复制机制\&quot;],\&quot;text\&quot;:[0,\&quot;写时复制机制\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;7从镜像仓库获得镜像\&quot;],\&quot;text\&quot;:[0,\&quot;7.从镜像仓库获得镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;镜像仓库\&quot;],\&quot;text\&quot;:[0,\&quot;镜像仓库\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;获取镜像\&quot;],\&quot;text\&quot;:[0,\&quot;获取镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;dokcer-hub镜像仓库\&quot;],\&quot;text\&quot;:[0,\&quot;Dokcer Hub镜像仓库\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-hub搜索镜像\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Hub搜索镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;管理镜像\&quot;],\&quot;text\&quot;:[0,\&quot;管理镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker的参数识别\&quot;],\&quot;text\&quot;:[0,\&quot;Docker的参数识别\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;删除镜像\&quot;],\&quot;text\&quot;:[0,\&quot;删除镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;8运行和管理容器\&quot;],\&quot;text\&quot;:[0,\&quot;8.运行和管理容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器的创建和启动\&quot;],\&quot;text\&quot;:[0,\&quot;容器的创建和启动。\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;创建容器\&quot;],\&quot;text\&quot;:[0,\&quot;创建容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;启动容器\&quot;],\&quot;text\&quot;:[0,\&quot;启动容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;创建和启动进行合并的docker命令\&quot;],\&quot;text\&quot;:[0,\&quot;创建和启动进行合并的docker命令\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;管理容器\&quot;],\&quot;text\&quot;:[0,\&quot;管理容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;停止和删除容器\&quot;],\&quot;text\&quot;:[0,\&quot;停止和删除容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;进入容器内部\&quot;],\&quot;text\&quot;:[0,\&quot;进入容器内部\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;9为容器配置网络\&quot;],\&quot;text\&quot;:[0,\&quot;9.为容器配置网络\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器网络\&quot;],\&quot;text\&quot;:[0,\&quot;容器网络\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器docker的网络实现\&quot;],\&quot;text\&quot;:[0,\&quot;容器Docker的网络实现\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;容器互联重点打通nigixh和web应用通信\&quot;],\&quot;text\&quot;:[0,\&quot;！！！容器互联（重点：打通nigixH和web应用通信）\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;暴露端口\&quot;],\&quot;text\&quot;:[0,\&quot;！！！暴露端口\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;通过别名连接\&quot;],\&quot;text\&quot;:[0,\&quot;通过别名连接\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;管理网络\&quot;],\&quot;text\&quot;:[0,\&quot;管理网络\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;创建网络和指定网络加入容器\&quot;],\&quot;text\&quot;:[0,\&quot;！！！创建网络和指定网络加入容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;端口映射\&quot;],\&quot;text\&quot;:[0,\&quot;！！！端口映射\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;10管理和存储数据\&quot;],\&quot;text\&quot;:[0,\&quot;10.管理和存储数据\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;数据管理方式的实现\&quot;],\&quot;text\&quot;:[0,\&quot;数据管理方式的实现。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;挂载方式\&quot;],\&quot;text\&quot;:[0,\&quot;挂载方式：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;挂载文件到容器\&quot;],\&quot;text\&quot;:[0,\&quot;挂载文件到容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;注意挂载数据卷\&quot;],\&quot;text\&quot;:[0,\&quot;注意挂载数据卷\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;11保存和共享镜像\&quot;],\&quot;text\&quot;:[0,\&quot;11.保存和共享镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;提交容器更新\&quot;],\&quot;text\&quot;:[0,\&quot;提交容器更新\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;为镜像命名\&quot;],\&quot;text\&quot;:[0,\&quot;为镜像命名\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;12dockerfile创建镜像\&quot;],\&quot;text\&quot;:[0,\&quot;12.Dockerfile创建镜像？？\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;dockerfile\&quot;],\&quot;text\&quot;:[0,\&quot;Dockerfile\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;环境搭建与镜像构建\&quot;],\&quot;text\&quot;:[0,\&quot;环境搭建与镜像构建\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;常见-dockerfile-指令\&quot;],\&quot;text\&quot;:[0,\&quot;常见 Dockerfile 指令\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;from\&quot;],\&quot;text\&quot;:[0,\&quot;FROM\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;run\&quot;],\&quot;text\&quot;:[0,\&quot;RUN\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;entrypoint-和-cmd\&quot;],\&quot;text\&quot;:[0,\&quot;ENTRYPOINT 和 CMD\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;copy-和-add\&quot;],\&quot;text\&quot;:[0,\&quot;COPY 和 ADD\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;构建镜像\&quot;],\&quot;text\&quot;:[0,\&quot;构建镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;13dockerfile的使用技巧\&quot;],\&quot;text\&quot;:[0,\&quot;13.Dockerfile的使用技巧\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;构建中使用变量\&quot;],\&quot;text\&quot;:[0,\&quot;构建中使用变量\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;环境变量\&quot;],\&quot;text\&quot;:[0,\&quot;环境变量\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;临摹案例\&quot;],\&quot;text\&quot;:[0,\&quot;临摹案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;14常见的docker-hub的镜像\&quot;],\&quot;text\&quot;:[0,\&quot;14.常见的docker hub的镜像\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;选择镜像和程序版本\&quot;],\&quot;text\&quot;:[0,\&quot;选择镜像和程序版本\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;15使用docker-compose管理容器\&quot;],\&quot;text\&quot;:[0,\&quot;15.使用Docker Compose管理容器\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;解决容器管理的问题\&quot;],\&quot;text\&quot;:[0,\&quot;解决容器管理的问题\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-compose\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Compose\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;linux安装-docker-composedocker-compose安装\&quot;],\&quot;text\&quot;:[0,\&quot;linux安装 Docker Compose:docker-compose安装\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;在-windows-和-macos-中的-docker-compose\&quot;],\&quot;text\&quot;:[0,\&quot;在 Windows 和 macOS 中的 Docker Compose\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;docker-compose-的基本使用逻辑\&quot;],\&quot;text\&quot;:[0,\&quot;Docker Compose 的基本使用逻辑\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;启动和停止\&quot;],\&quot;text\&quot;:[0,\&quot;启动和停止\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;容器命令\&quot;],\&quot;text\&quot;:[0,\&quot;容器命令\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;注意开机启动wsl配置\&quot;],\&quot;text\&quot;:[0,\&quot;注意开机启动WSL配置\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;16常用的-docker-compose-配置项\&quot;],\&quot;text\&quot;:[0,\&quot;16.！！！常用的 Docker Compose 配置项\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;首先\&quot;],\&quot;text\&quot;:[0,\&quot;首先\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;17编写-docker-compose-项目\&quot;],\&quot;text\&quot;:[0,\&quot;17.编写 Docker Compose 项目\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;设置项目的目录结构\&quot;],\&quot;text\&quot;:[0,\&quot;设置项目的目录结构。\&quot;]}]]&quot;],&quot;class&quot;:[0,&quot;astro-ROIVMLUZ&quot;]}" ssr="" client="media" opts="{&quot;name&quot;:&quot;TableOfContents&quot;,&quot;value&quot;:&quot;(min-width: 50em)&quot;}" await-children=""><h2 id="on-this-page-heading" class="heading">目录</h2><ul><li class="header-link depth-3"><a href="#dockerjeninsgitlab部署记录">docker+jenins+gitlab部署记录</a></li><li class="header-link depth-3"><a href="#docker学习">docker学习</a></li><li class="header-link depth-3"><a href="#1docker简历">1.Docker简历</a></li><li class="header-link depth-3"><a href="#2docker核心组成">2.Docker核心组成</a></li><li class="header-link depth-3"><a href="#3dokcer运行环境搭建">3.Dokcer运行环境搭建</a></li><li class="header-link depth-3"><a href="#windows中使用docker原理">windows中使用Docker原理</a></li><li class="header-link depth-3"><a href="#6镜像与容器">6.镜像与容器</a></li><li class="header-link depth-3"><a href="#7从镜像仓库获得镜像">7.从镜像仓库获得镜像</a></li><li class="header-link depth-3"><a href="#8运行和管理容器">8.运行和管理容器</a></li><li class="header-link depth-3"><a href="#9为容器配置网络">9.为容器配置网络</a></li><li class="header-link depth-3"><a href="#10管理和存储数据">10.管理和存储数据</a></li><li class="header-link depth-3"><a href="#11保存和共享镜像">11.保存和共享镜像</a></li><li class="header-link depth-3"><a href="#12dockerfile创建镜像">12.Dockerfile创建镜像？？</a></li><li class="header-link depth-3"><a href="#13dockerfile的使用技巧">13.Dockerfile的使用技巧</a></li><li class="header-link depth-3"><a href="#14常见的docker-hub的镜像">14.常见的docker hub的镜像</a></li><li class="header-link depth-3"><a href="#15使用docker-compose管理容器">15.使用Docker Compose管理容器</a></li><li class="header-link depth-3"><a href="#16常用的-docker-compose-配置项">16.！！！常用的 Docker Compose 配置项</a></li><li class="header-link depth-3"><a href="#17编写-docker-compose-项目">17.编写 Docker Compose 项目</a></li></ul></astro-island>
		<h2 class="heading astro-BYIKQF6W">More</h2>
<ul class="astro-BYIKQF6W">
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a class="edit-on-github astro-BYIKQF6W" href="https://github.com/nyhxiaoning/nyhxiaoning.github.io/blob/master/src/content/docs/en/15%E5%B7%A5%E5%85%B7%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/004docker%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0.md" target="_blank">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="pen" class="svg-inline--fa fa-pen fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Edit this page</span>
				</a>
			</li>
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a href="https://astro.build/chat" target="_blank" class="astro-BYIKQF6W">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="comment-alt" class="svg-inline--fa fa-comment-alt fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 9.8 11.2 15.5 19.1 9.7L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Join our community</span>
				</a>
			</li>
</ul>
<div style="margin: 2rem 0; text-align: center;" class="astro-BYIKQF6W">
	<astro-island uid="Z25Qg0T" component-url="/_astro/ThemeToggleButton.90e627d1.js" component-export="default" renderer-url="/_astro/client.15ddb572.js" props="{&quot;class&quot;:[0,&quot;astro-BYIKQF6W&quot;]}" ssr="" client="visible" opts="{&quot;name&quot;:&quot;ThemeToggleButton&quot;,&quot;value&quot;:true}" await-children=""><div class="theme-toggle"><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clipRule="evenodd"></path></svg><input type="radio" name="theme-toggle" value="light" title="Use light theme" aria-label="Use light theme" /></label><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg><input type="radio" name="theme-toggle" value="dark" title="Use dark theme" aria-label="Use dark theme" /></label></div></astro-island>
</div>
	</div>
</nav>
			</aside>
		</main>
		<!-- <footer> --><!-- <AvatarList path={path} /> --><!-- </footer> -->
	</body></html>