<!DOCTYPE html>
<html dir="ltr" lang="en-us" class="initial astro-OUAMJN2I">
  <head>
    <!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Astro v2.1.2">

<link rel="icon" type="image/svg+xml" href="/favicon.svg">

<link rel="sitemap" href="/sitemap.xml">

<!-- Preload Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital@0;1&display=swap" rel="stylesheet">

<!-- Scrollable a11y code helper -->
<script src="/make-scrollable-code-focusable.js"></script>

<!-- This is intentionally inlined to avoid FOUC -->
<script>
	const root = document.documentElement;
	const theme = localStorage.getItem('theme');
	if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
		root.classList.add('theme-dark');
	} else {
		root.classList.remove('theme-dark');
	}
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-TEL60V1WM9" is:inline></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-TEL60V1WM9');
</script> -->
    <!-- Page Metadata --><link rel="canonical" href="https://henry-git-master-nyhxiaoning/en/07react%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/001%E5%9F%BA%E7%A1%80react%E7%AC%94%E8%AE%B0%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/">

<!-- OpenGraph Tags -->
<meta property="og:title" content="全栈记录之旅 🚀 全栈记录之旅">
<meta property="og:type" content="article">
<meta property="og:url" content="https://henry-git-master-nyhxiaoning/en/07react%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/001%E5%9F%BA%E7%A1%80react%E7%AC%94%E8%AE%B0%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/">
<meta property="og:locale" content="en-us">
<meta property="og:image" content="https://github.com/withastro/astro/blob/main/assets/social/banner-minimal.png?raw=true">
<meta property="og:image:alt" content="astro logo on a starry expanse of space, with a purple saturn-like planet floating in the right foreground">
<meta name="description" property="og:description" content="成长依旧，步履不停">
<meta property="og:site_name" content="全栈记录之旅">

<!-- Twitter Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="astrodotbuild">
<meta name="twitter:title" content="全栈记录之旅 🚀 全栈记录之旅">
<meta name="twitter:description" content="成长依旧，步履不停">
<meta name="twitter:image" content="https://github.com/withastro/astro/blob/main/assets/social/banner-minimal.png?raw=true">
<meta name="twitter:image:alt" content="astro logo on a starry expanse of space, with a purple saturn-like planet floating in the right foreground">

<!--
  TODO: Add json+ld data, maybe https://schema.org/APIReference makes sense?
  Docs: https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data
  https://www.npmjs.com/package/schema-dts seems like a great resource for implementing this.
  Even better, there's a React component that integrates with `schema-dts`: https://github.com/google/react-schemaorg
-->
    <title>
      全栈记录之旅 🚀 全栈记录之旅
    </title>
    
    
  <link rel="stylesheet" href="/_astro/_...slug_.699682f2.css" /></head>

  <body class="astro-OUAMJN2I">
    <header class="astro-2W66RQV5">
	<a href="#article" class="sr-only focus:not-sr-only skiplink astro-DMGOOZ7Y"><span class="astro-DMGOOZ7Y">Skip to Content</span></a>
	<nav class="nav-wrapper astro-2W66RQV5" title="Top Navigation">
		<div class="menu-toggle astro-2W66RQV5">
			<style>astro-island,astro-slot{display:contents}</style><script>(self.Astro=self.Astro||{}).idle=t=>{const e=async()=>{await(await t())()};"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,200)},window.dispatchEvent(new Event("astro:idle"));var l;{const c={0:t=>t,1:t=>JSON.parse(t,o),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(JSON.parse(t,o)),5:t=>new Set(JSON.parse(t,o)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(JSON.parse(t)),9:t=>new Uint16Array(JSON.parse(t)),10:t=>new Uint32Array(JSON.parse(t))},o=(t,s)=>{if(t===""||!Array.isArray(s))return s;const[e,n]=s;return e in c?c[e](n):void 0};customElements.get("astro-island")||customElements.define("astro-island",(l=class extends HTMLElement{constructor(){super(...arguments);this.hydrate=()=>{if(!this.hydrator||this.parentElement&&this.parentElement.closest("astro-island[ssr]"))return;const s=this.querySelectorAll("astro-slot"),e={},n=this.querySelectorAll("template[data-astro-template]");for(const r of n){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(const r of s){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("name")||"default"]=r.innerHTML)}const a=this.hasAttribute("props")?JSON.parse(this.getAttribute("props"),o):{};this.hydrator(this)(this.Component,a,e,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),window.removeEventListener("astro:hydrate",this.hydrate),window.dispatchEvent(new CustomEvent("astro:hydrate"))}}connectedCallback(){!this.hasAttribute("await-children")||this.firstChild?this.childrenConnectedCallback():new MutationObserver((s,e)=>{e.disconnect(),this.childrenConnectedCallback()}).observe(this,{childList:!0})}async childrenConnectedCallback(){window.addEventListener("astro:hydrate",this.hydrate);let s=this.getAttribute("before-hydration-url");s&&await import(s),this.start()}start(){const s=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(Astro[e]===void 0){window.addEventListener(`astro:${e}`,()=>this.start(),{once:!0});return}Astro[e](async()=>{const n=this.getAttribute("renderer-url"),[a,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),i=this.getAttribute("component-export")||"default";if(!i.includes("."))this.Component=a[i];else{this.Component=a;for(const d of i.split("."))this.Component=this.Component[d]}return this.hydrator=r,this.hydrate},s,this)}attributeChangedCallback(){this.hydrator&&this.hydrate()}},l.observedAttributes=["props"],l))}</script><astro-island uid="Rxydg" component-url="/_astro/SidebarToggle.65a801f9.js" component-export="default" renderer-url="/_astro/client.2b526cb2.js" props="{&quot;class&quot;:[0,&quot;astro-2W66RQV5&quot;]}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;SidebarToggle&quot;,&quot;value&quot;:true}" await-children=""><button type="button" aria-pressed="false" id="menu-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg><span class="sr-only">Toggle sidebar</span></button></astro-island>
		</div>
		<div class="logo flex astro-2W66RQV5">
			<a href="/" class="astro-2W66RQV5">
				<svg class="logo" width="40" height="40" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
	<style>
		#flame {
			fill: var(--theme-text-accent);
		}

		#a {
			fill: var(--theme-text-accent);
		}
	</style>
	<title>Logo:文档中心</title>
	<path id="a" fill-rule="evenodd" clip-rule="evenodd" d="M163.008 18.929c1.944 2.413 2.935 5.67 4.917 12.181l43.309 142.27a180.277 180.277 0 00-51.778-17.53l-28.198-95.29a3.67 3.67 0 00-7.042.01l-27.857 95.232a180.225 180.225 0 00-52.01 17.557l43.52-142.281c1.99-6.502 2.983-9.752 4.927-12.16a15.999 15.999 0 016.484-4.798c2.872-1.154 6.271-1.154 13.07-1.154h31.085c6.807 0 10.211 0 13.086 1.157a16.004 16.004 0 016.487 4.806z">
	</path>
	<path id="flame" fill-rule="evenodd" clip-rule="evenodd" d="M168.19 180.151c-7.139 6.105-21.39 10.268-37.804 10.268-20.147 0-37.033-6.272-41.513-14.707-1.602 4.835-1.961 10.367-1.961 13.902 0 0-1.056 17.355 11.015 29.426 0-6.268 5.081-11.349 11.349-11.349 10.743 0 10.731 9.373 10.721 16.977v.679c0 11.542 7.054 21.436 17.086 25.606a23.27 23.27 0 01-2.339-10.2c0-11.008 6.463-15.107 13.974-19.87 5.976-3.79 12.616-8.001 17.192-16.449a31.024 31.024 0 003.743-14.82c0-3.299-.513-6.479-1.463-9.463z">
	</path>
</svg>
				<h1 class="astro-2W66RQV5">全栈记录之旅</h1>
			</a>
		</div>
		<div style="flex-grow: 1;" class="astro-2W66RQV5"></div>
		
		<div class="search-item astro-2W66RQV5">
			<astro-island uid="pp6Cr" component-url="/_astro/Search.aa1cadd5.js" component-export="default" renderer-url="/_astro/client.fd400d45.js" props="{}" ssr="" client="idle" opts="{&quot;name&quot;:&quot;Search&quot;,&quot;value&quot;:true}" await-children=""><button type="button" class="search-input"><svg width="24" height="24" fill="none"><path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><span>Search</span><span class="search-hint"><span class="sr-only">Press </span><kbd>/</kbd><span class="sr-only"> to search</span></span></button></astro-island>
		</div>
	</nav>
</header>
    <main class="layout astro-OUAMJN2I">
      <aside id="grid-left" class="grid-sidebar astro-OUAMJN2I" title="Site Navigation">
        <nav aria-labelledby="grid-left" class="astro-KQNE5HRN">
  <ul class="nav-groups astro-KQNE5HRN">
    <li class="astro-KQNE5HRN">
          <div class="nav-group astro-KQNE5HRN">
            <h2 class="astro-KQNE5HRN">记录是学习的开始</h2>
            <ul class="astro-KQNE5HRN">
              <li class="nav-link astro-KQNE5HRN">
                    <a href="/en/introduction" class="astro-KQNE5HRN">
                      全栈学习
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/zero" class="astro-KQNE5HRN">
                      0个人前端项目实战记录和链接
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/first" class="astro-KQNE5HRN">
                      01 React 课程学习和问题笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/second" class="astro-KQNE5HRN">
                      02 极客时间Vue课程学习和问题笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/third" class="astro-KQNE5HRN">
                      03 掘金算法课程学习和问题笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/fourth" class="astro-KQNE5HRN">
                      04 掘金 Uniapp 课程和Taro或原生小程序学习笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/fifth" class="astro-KQNE5HRN">
                      05 leetcode 刷题记录每周
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/sixth" class="astro-KQNE5HRN">
                      06 极客时间 Node 全栈记录
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/seventh" class="astro-KQNE5HRN">
                      07 React 学习常见问题和笔记记录
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/eighth" class="astro-KQNE5HRN">
                      08 vue 常见问题和学习记录
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/ninth" class="astro-KQNE5HRN">
                      09 book 前端进阶知识学习图书笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/tenth" class="astro-KQNE5HRN">
                      10 book 前端开发设计模式和开发实战笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/eleventh" class="astro-KQNE5HRN">
                      11 elementplus 经典源码和实战学习和问题笔记
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/twelfth" class="astro-KQNE5HRN">
                      12 前端开发经典库学习记录
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/thirteenth" class="astro-KQNE5HRN">
                      13 Koa和express 框架学习记录
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/fourteenth" class="astro-KQNE5HRN">
                      14 前端图形化学习
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/fifteenth" class="astro-KQNE5HRN">
                      15工具和项目配置工程化问题记录
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/sixteenth" class="astro-KQNE5HRN">
                      16 前端拓展知识学习
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/seventeenth" class="astro-KQNE5HRN">
                      17 低代码学习和总结
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/eighteen" class="astro-KQNE5HRN">
                      18 经验亮点汇总( 迁移中 )
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/ninghteen" class="astro-KQNE5HRN">
                      19 项目复盘汇总( 迁移中 )
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/others" class="astro-KQNE5HRN">
                      其他常见问题
                    </a>
                  </li><li class="nav-link astro-KQNE5HRN">
                    <a href="/en/notices" class="astro-KQNE5HRN">
                      常用符号
                    </a>
                  </li>
            </ul>
          </div>
        </li><li class="astro-KQNE5HRN">
          <div class="nav-group astro-KQNE5HRN">
            <h2 class="astro-KQNE5HRN">其他说明</h2>
            <ul class="astro-KQNE5HRN">
              <li class="nav-link astro-KQNE5HRN">
                    <a href="/en/page-4" class="astro-KQNE5HRN">
                      自定义
                    </a>
                  </li>
            </ul>
          </div>
        </li>
  </ul>
</nav>
      </aside>
      <div id="grid-main" class="astro-OUAMJN2I">
        <article id="article" class="content astro-J75B3YUS">
  <section class="main-section astro-J75B3YUS">
    <h1 class="content-title astro-J75B3YUS" id="overview">全栈记录之旅</h1>
    <nav class="block sm:hidden astro-J75B3YUS">
      <script>(self.Astro=self.Astro||{}).media=(s,a)=>{const t=async()=>{await(await s())()};if(a.value){const e=matchMedia(a.value);e.matches?t():e.addEventListener("change",t,{once:!0})}},window.dispatchEvent(new Event("astro:media"));</script><astro-island uid="1SXq7I" component-url="/_astro/TableOfContents.3058fe45.js" component-export="default" renderer-url="/_astro/client.2b526cb2.js" props="{&quot;headings&quot;:[1,&quot;[[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;一些常见使用习惯\&quot;],\&quot;text\&quot;:[0,\&quot;一些常见使用习惯\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;组件的开发必须使用大驼峰命名\&quot;],\&quot;text\&quot;:[0,\&quot;组件的开发必须使用大驼峰命名\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;jsx-使用说明习惯\&quot;],\&quot;text\&quot;:[0,\&quot;jsx 使用说明习惯\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;classname\&quot;],\&quot;text\&quot;:[0,\&quot;className\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;所有-react-组件都必须像纯函数一样保护它们的-props-不被更改\&quot;],\&quot;text\&quot;:[0,\&quot;所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;jsx-中写注释括起来\&quot;],\&quot;text\&quot;:[0,\&quot;jsx 中写注释：${}括起来\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;jsx-中自定义组件名称必须以大写字母开头\&quot;],\&quot;text\&quot;:[0,\&quot;jsx 中自定义组件名称必须以大写字母开头。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;reactdom-渲染前默认将输入所有的内容进行转义\&quot;],\&quot;text\&quot;:[0,\&quot;ReactDom 渲染前，默认将输入所有的内容进行转义。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;避免将-props-的值复制给-state这是一个常见的错误\&quot;],\&quot;text\&quot;:[0,\&quot;避免将 props 的值复制给 state！这是一个常见的错误：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;componentdidupdate必须注意它必须被包裹在一个条件语句里\&quot;],\&quot;text\&quot;:[0,\&quot;componentDidUpdate()必须注意它必须被包裹在一个条件语句里\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;一般-react-构建的应用通常只有单一的根-dom-节点\&quot;],\&quot;text\&quot;:[0,\&quot;一般 React 构建的应用通常只有单一的根 DOM 节点。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;1jsx-转换使用特定属性值\&quot;],\&quot;text\&quot;:[0,\&quot;1.jsx 转换使用特定属性值\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第三章元素渲染\&quot;],\&quot;text\&quot;:[0,\&quot;第三章：元素渲染\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;1更新已经渲染的元素\&quot;],\&quot;text\&quot;:[0,\&quot;1.更新已经渲染的元素\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;2react-只更新它需要更新的部分\&quot;],\&quot;text\&quot;:[0,\&quot;2.React 只更新它需要更新的部分\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第四章组件和-pops\&quot;],\&quot;text\&quot;:[0,\&quot;第四章：组件和 Pops\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;函数组件和-class-组件\&quot;],\&quot;text\&quot;:[0,\&quot;函数组件和 class 组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;js-函数定义一个函数组件\&quot;],\&quot;text\&quot;:[0,\&quot;js 函数定义一个函数组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;class-组件\&quot;],\&quot;text\&quot;:[0,\&quot;class 组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;渲染组件\&quot;],\&quot;text\&quot;:[0,\&quot;渲染组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;props-的只读性\&quot;],\&quot;text\&quot;:[0,\&quot;props 的只读性\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;5state-和生命周期\&quot;],\&quot;text\&quot;:[0,\&quot;5.state 和生命周期\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;组件的生命周期\&quot;],\&quot;text\&quot;:[0,\&quot;组件的生命周期\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;当组件实例被创建并插入-dom-中时其生命周期调用顺序如下\&quot;],\&quot;text\&quot;:[0,\&quot;当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;组件更新时调用顺序\&quot;],\&quot;text\&quot;:[0,\&quot;组件更新时，调用顺序\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;当然这些所有的都是手动的调用和-vue-一样如果只是确保一些单一的功能可以调用必要的\&quot;],\&quot;text\&quot;:[0,\&quot;当然这些所有的都是手动的调用（和 vue 一样，如果只是确保一些单一的功能，可以调用必要的）\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;重复调用相同的值有一个类似-vue-的计算属性-memoization-帮助函数来阻止非必要的过滤\&quot;],\&quot;text\&quot;:[0,\&quot;重复调用相同的值，有一个类似 vue 的计算属性， memoization 帮助函数来阻止非必要的过滤：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;组件卸载调用方法\&quot;],\&quot;text\&quot;:[0,\&quot;组件卸载调用方法\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;错误处理\&quot;],\&quot;text\&quot;:[0,\&quot;错误处理\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;总的来说-react-分为两大阶段render-阶段和-commit-阶段常用如下\&quot;],\&quot;text\&quot;:[0,\&quot;总的来说 React 分为两大阶段：render 阶段和 commit 阶段（常用如下）\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;函数组件转换为-class-组件\&quot;],\&quot;text\&quot;:[0,\&quot;函数组件转换为 class 组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;向-class-中添加局部的-state\&quot;],\&quot;text\&quot;:[0,\&quot;向 class 中添加局部的 state\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;将生命周期方法添加到-class\&quot;],\&quot;text\&quot;:[0,\&quot;将生命周期方法添加到 class\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;正确的使用-state\&quot;],\&quot;text\&quot;:[0,\&quot;正确的使用 State\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第六章react-事件处理\&quot;],\&quot;text\&quot;:[0,\&quot;第六章：React 事件处理\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;事件处理的语法\&quot;],\&quot;text\&quot;:[0,\&quot;事件处理的语法\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;向事件处理程序传递参数\&quot;],\&quot;text\&quot;:[0,\&quot;向事件处理程序传递参数\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第七章条件渲染\&quot;],\&quot;text\&quot;:[0,\&quot;第七章：条件渲染\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;true--expression-总是会返回-expression\&quot;],\&quot;text\&quot;:[0,\&quot;true &amp;&amp; expression 总是会返回 expression。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;阻止组件渲染\&quot;],\&quot;text\&quot;:[0,\&quot;阻止组件渲染\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第八章列表--key\&quot;],\&quot;text\&quot;:[0,\&quot;第八章：列表 &amp; Key\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;key-帮助-react-识别哪些元素改变了比如被添加或删除因此你应当给数组中的每一个元素赋予一个确定的标识\&quot;],\&quot;text\&quot;:[0,\&quot;key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;用-key-提取组件\&quot;],\&quot;text\&quot;:[0,\&quot;用 key 提取组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;key-只是在兄弟节点之间必须唯一\&quot;],\&quot;text\&quot;:[0,\&quot;key 只是在兄弟节点之间必须唯一\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;key-会传递信息给-react-但不会传递给你的组件如果你的组件中需要使用-key-属性的值请用其他属性名显式传递这个值\&quot;],\&quot;text\&quot;:[0,\&quot;key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第九章在-react-里html-表单元素的工作方式和其他的-dom-元素有些不同\&quot;],\&quot;text\&quot;:[0,\&quot;第九章：在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;受控组件\&quot;],\&quot;text\&quot;:[0,\&quot;受控组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;textarea-标签\&quot;],\&quot;text\&quot;:[0,\&quot;textarea 标签\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;select-标签\&quot;],\&quot;text\&quot;:[0,\&quot;select 标签\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;input-标签\&quot;],\&quot;text\&quot;:[0,\&quot;input 标签\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;处理多个输入可以给每一个元素添加-name根据函数-eventtargetname-的值选择\&quot;],\&quot;text\&quot;:[0,\&quot;处理多个输入，可以给每一个元素添加 name,根据函数 event.target.name 的值选择\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;受控组件和非受控组件\&quot;],\&quot;text\&quot;:[0,\&quot;受控组件和非受控组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;一些外部嵌套-react-的快速-demo使用非受控组件操作-dom\&quot;],\&quot;text\&quot;:[0,\&quot;一些外部嵌套 react 的快速 demo,使用非受控组件操作 dom\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第十章状态提升\&quot;],\&quot;text\&quot;:[0,\&quot;第十章：状态提升\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第十一章\&quot;],\&quot;text\&quot;:[0,\&quot;第十一章\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;props-和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式\&quot;],\&quot;text\&quot;:[0,\&quot;Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;props-和-state-区别\&quot;],\&quot;text\&quot;:[0,\&quot;props 和 state 区别\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;12react-设计哲学\&quot;],\&quot;text\&quot;:[0,\&quot;12.React 设计哲学\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第一步将设计好的-ui-分为组件层级\&quot;],\&quot;text\&quot;:[0,\&quot;第一步将设计好的 UI 分为组件层级\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第二步搭建基础的静态-ui-页面\&quot;],\&quot;text\&quot;:[0,\&quot;第二步搭建基础的静态 UI 页面\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第三步定义数据结构确定-ui-的-state-的最小表示\&quot;],\&quot;text\&quot;:[0,\&quot;第三步：定义数据结构，确定 UI 的 state 的最小表示\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第四步确定-state-的设置位置\&quot;],\&quot;text\&quot;:[0,\&quot;第四步：确定 state 的设置位置。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第五步添加反向数据流\&quot;],\&quot;text\&quot;:[0,\&quot;第五步：添加反向数据流\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;补充一个小知识\&quot;],\&quot;text\&quot;:[0,\&quot;补充一个小知识\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;ref-转发是一项将-ref-自动地通过组件传递到其一子组件的技巧\&quot;],\&quot;text\&quot;:[0,\&quot;Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;案例\&quot;],\&quot;text\&quot;:[0,\&quot;案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;注意自动绑定如何-class-中的方法自动绑定-this\&quot;],\&quot;text\&quot;:[0,\&quot;注意自动绑定，如何 class 中的方法自动绑定 this\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;手动绑定-this\&quot;],\&quot;text\&quot;:[0,\&quot;手动绑定 this\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;自定实现组件的绑定-this\&quot;],\&quot;text\&quot;:[0,\&quot;自定实现组件的绑定 this\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;fragments\&quot;],\&quot;text\&quot;:[0,\&quot;Fragments\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;另外一种短语法则\&quot;],\&quot;text\&quot;:[0,\&quot;另外一种短语法则\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;代码分割\&quot;],\&quot;text\&quot;:[0,\&quot;代码分割\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;使用之前案例\&quot;],\&quot;text\&quot;:[0,\&quot;使用之前案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;使用之后案例\&quot;],\&quot;text\&quot;:[0,\&quot;使用之后案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;代码懒加载-lazy\&quot;],\&quot;text\&quot;:[0,\&quot;代码懒加载 lazy\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;深入-jsx\&quot;],\&quot;text\&quot;:[0,\&quot;深入 JSX\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;jsx-类型中使用点语法\&quot;],\&quot;text\&quot;:[0,\&quot;JSX 类型中使用点语法\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;用户定义的组件必须以大写字母开头\&quot;],\&quot;text\&quot;:[0,\&quot;用户定义的组件必须以大写字母开头\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;高阶组件-hoc-暂停\&quot;],\&quot;text\&quot;:[0,\&quot;高阶组件 HOC 暂停\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;hoc-常见的高阶组件\&quot;],\&quot;text\&quot;:[0,\&quot;HOC 常见的高阶组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;组件是-react-中代码复用的基本单元但是某些模式下不适合传统组件\&quot;],\&quot;text\&quot;:[0,\&quot;组件是 React 中代码复用的基本单元，但是某些模式下，不适合传统组件。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;案例学习commentlist-组件订阅外部数据源渲染评论列表\&quot;],\&quot;text\&quot;:[0,\&quot;案例学习：commentlist 组件，订阅外部数据源，渲染评论列表\&quot;]}]]&quot;],&quot;class&quot;:[0,&quot;astro-J75B3YUS&quot;]}" ssr="" client="media" opts="{&quot;name&quot;:&quot;TableOfContents&quot;,&quot;value&quot;:&quot;(max-width: 50em)&quot;}" await-children=""><h2 id="on-this-page-heading" class="heading">目录</h2><ul><li class="header-link depth-3"><a href="#一些常见使用习惯">一些常见使用习惯</a></li><li class="header-link depth-3"><a href="#1jsx-转换使用特定属性值">1.jsx 转换使用特定属性值</a></li><li class="header-link depth-3"><a href="#1更新已经渲染的元素">1.更新已经渲染的元素</a></li><li class="header-link depth-3"><a href="#2react-只更新它需要更新的部分">2.React 只更新它需要更新的部分</a></li><li class="header-link depth-3"><a href="#函数组件和-class-组件">函数组件和 class 组件</a></li><li class="header-link depth-3"><a href="#渲染组件">渲染组件</a></li><li class="header-link depth-3"><a href="#props-的只读性">props 的只读性</a></li><li class="header-link depth-3"><a href="#组件的生命周期">组件的生命周期</a></li><li class="header-link depth-3"><a href="#正确的使用-state">正确的使用 State</a></li><li class="header-link depth-3"><a href="#事件处理的语法">事件处理的语法</a></li><li class="header-link depth-3"><a href="#向事件处理程序传递参数">向事件处理程序传递参数</a></li><li class="header-link depth-3"><a href="#true--expression-总是会返回-expression">true &amp;&amp; expression 总是会返回 expression。</a></li><li class="header-link depth-3"><a href="#阻止组件渲染">阻止组件渲染</a></li><li class="header-link depth-3"><a href="#key-帮助-react-识别哪些元素改变了比如被添加或删除因此你应当给数组中的每一个元素赋予一个确定的标识">key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</a></li><li class="header-link depth-3"><a href="#用-key-提取组件">用 key 提取组件</a></li><li class="header-link depth-3"><a href="#key-只是在兄弟节点之间必须唯一">key 只是在兄弟节点之间必须唯一</a></li><li class="header-link depth-3"><a href="#key-会传递信息给-react-但不会传递给你的组件如果你的组件中需要使用-key-属性的值请用其他属性名显式传递这个值">key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：</a></li><li class="header-link depth-3"><a href="#受控组件">受控组件</a></li><li class="header-link depth-3"><a href="#textarea-标签">textarea 标签</a></li><li class="header-link depth-3"><a href="#select-标签">select 标签</a></li><li class="header-link depth-3"><a href="#input-标签">input 标签</a></li><li class="header-link depth-3"><a href="#处理多个输入可以给每一个元素添加-name根据函数-eventtargetname-的值选择">处理多个输入，可以给每一个元素添加 name,根据函数 event.target.name 的值选择</a></li><li class="header-link depth-3"><a href="#受控组件和非受控组件">受控组件和非受控组件</a></li><li class="header-link depth-3"><a href="#第一步将设计好的-ui-分为组件层级">第一步将设计好的 UI 分为组件层级</a></li><li class="header-link depth-3"><a href="#第二步搭建基础的静态-ui-页面">第二步搭建基础的静态 UI 页面</a></li><li class="header-link depth-3"><a href="#第三步定义数据结构确定-ui-的-state-的最小表示">第三步：定义数据结构，确定 UI 的 state 的最小表示</a></li><li class="header-link depth-3"><a href="#第四步确定-state-的设置位置">第四步：确定 state 的设置位置。</a></li><li class="header-link depth-3"><a href="#第五步添加反向数据流">第五步：添加反向数据流</a></li><li class="header-link depth-3"><a href="#案例">案例</a></li><li class="header-link depth-3"><a href="#使用之前案例">使用之前案例</a></li><li class="header-link depth-3"><a href="#使用之后案例">使用之后案例</a></li><li class="header-link depth-3"><a href="#代码懒加载-lazy">代码懒加载 lazy</a></li><li class="header-link depth-3"><a href="#jsx-类型中使用点语法">JSX 类型中使用点语法</a></li><li class="header-link depth-3"><a href="#用户定义的组件必须以大写字母开头">用户定义的组件必须以大写字母开头</a></li><li class="header-link depth-3"><a href="#hoc-常见的高阶组件">HOC 常见的高阶组件</a></li><li class="header-link depth-3"><a href="#组件是-react-中代码复用的基本单元但是某些模式下不适合传统组件">组件是 React 中代码复用的基本单元，但是某些模式下，不适合传统组件。</a></li></ul></astro-island>
    </nav>
    <p>[toc]</p>
<h3 id="一些常见使用习惯">一些常见使用习惯</h3>
<h4 id="组件的开发必须使用大驼峰命名">组件的开发必须使用大驼峰命名</h4>
<h4 id="jsx-使用说明习惯">jsx 使用说明习惯</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">注意事项：</span></span>
<span class="line"><span style="color: #c9d1d9">1、JSX的语法很严格 所有的标签必须闭合</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;hr/>不能写成&#x3C;hr></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">2、JSX采用的是JS的注释方式 形如/* */ 或 //</span></span>
<span class="line"><span style="color: #c9d1d9">且由于是JSX语法 需写在花括号内部 像这样：</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">{/*我是注释*/}</span></span>
<span class="line"><span style="color: #c9d1d9">1</span></span>
<span class="line"><span style="color: #c9d1d9">或</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">{</span></span>
<span class="line"><span style="color: #c9d1d9">	// 我是注释</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">3、在为JSX语法的元素添加类名(class)的时候</span></span>
<span class="line"><span style="color: #c9d1d9">用className来替代class</span></span>
<span class="line"><span style="color: #c9d1d9">用htmlFor来替代for</span></span>
<span class="line"><span style="color: #c9d1d9">class和for是JS中的关键字 为了防止歧义 在JSX中必须换个关键字</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">4、在JSX语法中 创建DOM的时候 所有节点必须有唯一的根元素进行包裹</span></span>
<span class="line"><span style="color: #c9d1d9">就像Vue的&#x3C;template>里面一样 必须有唯一的根元素进行包裹 不能有多个平级的根元素</span></span></code></pre>
<h4 id="classname">className</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">1.jsx中的使用规范，一个jsx最好用小括号括起来，避免自动分号</span></span>
<span class="line"><span style="color: #c9d1d9">- jsx的语法更佳接近js而不是html,所以reactDOM使用小驼峰命名定义属性。jsx中class变成了className</span></span>
<span class="line"><span style="color: #c9d1d9">- class是关键字，在react中使用不方便</span></span></code></pre>
<h4 id="所有-react-组件都必须像纯函数一样保护它们的-props-不被更改">所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</h4>
<h4 id="jsx-中写注释括起来">jsx 中写注释：{}括起来</h4>
<h4 id="jsx-中自定义组件名称必须以大写字母开头">jsx 中自定义组件名称必须以大写字母开头。</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&#x3C;div /> 代表 HTML 的 div 标签，而 &#x3C;Welcome /> 则代表一个组件，并且需在作用域内使用 Welcome。</span></span></code></pre>
<h4 id="reactdom-渲染前默认将输入所有的内容进行转义">ReactDom 渲染前，默认将输入所有的内容进行转义。</h4>
<p>避免了 xss 攻击。</p>
<h4 id="避免将-props-的值复制给-state这是一个常见的错误">避免将 props 的值复制给 state！这是一个常见的错误：</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">constructor(props) {</span></span>
<span class="line"><span style="color: #c9d1d9"> super(props);</span></span>
<span class="line"><span style="color: #c9d1d9"> // 不要这样做</span></span>
<span class="line"><span style="color: #c9d1d9"> this.state = { color: props.color };</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9">如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="componentdidupdate必须注意它必须被包裹在一个条件语句里">componentDidUpdate()必须注意它必须被包裹在一个条件语句里</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">componentDidUpdate(prevProps) {</span></span>
<span class="line"><span style="color: #c9d1d9">  // 典型用法（不要忘记比较 props）：</span></span>
<span class="line"><span style="color: #c9d1d9">  if (this.props.userID !== prevProps.userID) {</span></span>
<span class="line"><span style="color: #c9d1d9">    this.fetchData(this.props.userID);</span></span>
<span class="line"><span style="color: #c9d1d9">  }</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="一般-react-构建的应用通常只有单一的根-dom-节点">一般 React 构建的应用通常只有单一的根 DOM 节点。</h4>
<p>但是如果将 React 集成到一个已经存在的应用，那么可以在应用中包含多个根 DOM
2.jsx 中的通过引号将属性值转为字符串字面量，</p>
<h3 id="1jsx-转换使用特定属性值">1.jsx 转换使用特定属性值</h3>
<p>方法 1：使用引号
方法 2：使用{}</p>
<h1 id="第三章元素渲染">第三章：元素渲染</h1>
<h3 id="1更新已经渲染的元素">1.更新已经渲染的元素</h3>
<p>React 元素是不可变对象，一般创建，不可以更改它的属性或是子元素，它代表了某一个特定时刻的 UI.</p>
<h3 id="2react-只更新它需要更新的部分">2.React 只更新它需要更新的部分</h3>
<h1 id="第四章组件和-pops">第四章：组件和 Pops</h1>
<p>组件概念上，类似于 js 函数，接受任意的入参，返回用于描述页面展示内容的 React 元素。</p>
<h3 id="函数组件和-class-组件">函数组件和 class 组件</h3>
<h4 id="js-函数定义一个函数组件">js 函数定义一个函数组件</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">function  welcome(props){</span></span>
<span class="line"><span style="color: #c9d1d9">    return &#x3C;h1>hello{props.name}&#x3C;/h1></span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="class-组件">class 组件</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">class  Welcome extends React.Component{</span></span>
<span class="line"><span style="color: #c9d1d9">    render(){</span></span>
<span class="line"><span style="color: #c9d1d9">        return &#x3C;h1>hello{this.props.name}&#x3C;/h1></span></span>
<span class="line"><span style="color: #c9d1d9">    }</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h3 id="渲染组件">渲染组件</h3>
<p>当 React 元素渲染用户自定义的组件时候，会将 jsx 所接收的属性以及子组件 children 转换为单个对象传递给组件，这个对象称为 props</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">上面定义好的函数（class组件）组件，使用</span></span>
<span class="line"><span style="color: #c9d1d9">const element = (&#x3C;Welcome  name="daning" />)</span></span>
<span class="line"><span style="color: #c9d1d9">ReactDOM.render(</span></span>
<span class="line"><span style="color: #c9d1d9">    element,</span></span>
<span class="line"><span style="color: #c9d1d9">    docuement.getElementById('root')</span></span>
<span class="line"><span style="color: #c9d1d9">)</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h3 id="props-的只读性">props 的只读性</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">组件不能修改自身的 props.</span></span>
<span class="line"><span style="color: #c9d1d9">纯函数，输入的内容和输出的内容唯一确定，不会输入相同输出不同。下面修改了入参。</span></span>
<span class="line"><span style="color: #c9d1d9">function withdraw(account, amount) {</span></span>
<span class="line"><span style="color: #c9d1d9">account.total -= amount;</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span></code></pre>
<h1 id="5state-和生命周期">5.state 和生命周期</h1>
<h3 id="组件的生命周期">组件的生命周期</h3>
<p>组件的生命周期。</p>
<h4 id="当组件实例被创建并插入-dom-中时其生命周期调用顺序如下">当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">1.constructor()</span></span>
<span class="line"><span style="color: #c9d1d9">    （1）通过给 this.state 赋值对象来初始化内部 state。</span></span>
<span class="line"><span style="color: #c9d1d9">    （2）为事件处理函数绑定实例</span></span>
<span class="line"><span style="color: #c9d1d9">2.static getDerivedStateFromProps()（它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。）</span></span>
<span class="line"><span style="color: #c9d1d9">3.render()</span></span>
<span class="line"><span style="color: #c9d1d9">4.componentDidMount()</span></span></code></pre>
<h4 id="组件更新时调用顺序">组件更新时，调用顺序</h4>
<p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">1.static getDerivedStateFromProps()</span></span>
<span class="line"><span style="color: #c9d1d9">2.shouldComponentUpdate()</span></span>
<span class="line"><span style="color: #c9d1d9">3.render()</span></span>
<span class="line"><span style="color: #c9d1d9">4.getSnapshotBeforeUpdate()</span></span>
<span class="line"><span style="color: #c9d1d9">5.componentDidUpdate()</span></span></code></pre>
<h6 id="当然这些所有的都是手动的调用和-vue-一样如果只是确保一些单一的功能可以调用必要的">当然这些所有的都是手动的调用（和 vue 一样，如果只是确保一些单一的功能，可以调用必要的）</h6>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">（1）如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate。</span></span>
<span class="line"><span style="color: #c9d1d9">componentDidUpdate() 会在更新后会被立即调用</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">（2）componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h6 id="重复调用相同的值有一个类似-vue-的计算属性-memoization-帮助函数来阻止非必要的过滤">重复调用相同的值，有一个类似 vue 的计算属性， memoization 帮助函数来阻止非必要的过滤：</h6>
<p>缓存上一次的值。</p>
<h4 id="组件卸载调用方法">组件卸载调用方法</h4>
<p>当组件从 DOM 中移除时会调用如下方法：</p>
<p>componentWillUnmount()</p>
<h4 id="错误处理">错误处理</h4>
<p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p>
<p>static getDerivedStateFromError()
componentDidCatch()</p>
<h4 id="总的来说-react-分为两大阶段render-阶段和-commit-阶段常用如下">总的来说 React 分为两大阶段：render 阶段和 commit 阶段（常用如下）</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">挂载时候，constructor->render->(更新 DOM 和 refs)componentDidMount</span></span>
<span class="line"><span style="color: #c9d1d9">更新时候，render->(更新 DOM 和 refs)componentDidMount</span></span>
<span class="line"><span style="color: #c9d1d9">卸载时候，componentWillUnmount</span></span></code></pre>
<h4 id="函数组件转换为-class-组件">函数组件转换为 class 组件</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">第一步，创建一个同名的ES6的class,并且继承于React.Component</span></span>
<span class="line"><span style="color: #c9d1d9">第二步，添加一个空的render方法</span></span>
<span class="line"><span style="color: #c9d1d9">第三步，将函数体移动到render()内部。</span></span>
<span class="line"><span style="color: #c9d1d9">第四步，将render中使用this.props替换props.</span></span>
<span class="line"><span style="color: #c9d1d9">第五步，删除剩余的空函数的声明。</span></span></code></pre>
<h4 id="向-class-中添加局部的-state">向 class 中添加局部的 state</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">如何将date从props移动到state中</span></span>
<span class="line"><span style="color: #c9d1d9">第一步，通过render方法中的this.props.date替换成this.state.date</span></span>
<span class="line"><span style="color: #c9d1d9">第二步，增加class的构造函数，然后在该函数中为this.state赋值初始值</span></span>
<span class="line"><span style="color: #c9d1d9">constructor(props){</span></span>
<span class="line"><span style="color: #c9d1d9">    super(props)</span></span>
<span class="line"><span style="color: #c9d1d9">    this.state = {date:new Date()}</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9">第三步，移除原函数组件中的date属性。</span></span>
<span class="line"><span style="color: #c9d1d9">ReactDOM.render(</span></span>
<span class="line"><span style="color: #c9d1d9">  &#x3C;Clock />,</span></span>
<span class="line"><span style="color: #c9d1d9">  document.getElementById('root')</span></span>
<span class="line"><span style="color: #c9d1d9">);</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="将生命周期方法添加到-class">将生命周期方法添加到 class</h4>
<p>将上面声明周期函数写入 class 中即可。</p>
<h3 id="正确的使用-state">正确的使用 State</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">1.不要直接修改State,使用setState函数</span></span>
<span class="line"><span style="color: #c9d1d9">// Wrong</span></span>
<span class="line"><span style="color: #c9d1d9">this.state.comment = 'Hello';</span></span>
<span class="line"><span style="color: #c9d1d9">this.setState({</span></span>
<span class="line"><span style="color: #c9d1d9">    comment:'12'</span></span>
<span class="line"><span style="color: #c9d1d9">})</span></span>
<span class="line"><span style="color: #c9d1d9">2.State的更新可能是异步的</span></span>
<span class="line"><span style="color: #c9d1d9">出于性能考虑，React可能会把多个setState当成一个调用。</span></span>
<span class="line"><span style="color: #c9d1d9">如果是多个对象，那么无法控制更新状态。</span></span>
<span class="line"><span style="color: #c9d1d9">setState接收一个函数，而不是一个对象。函数使用state作为参数，第二个参数props.</span></span>
<span class="line"><span style="color: #c9d1d9">// Correct</span></span>
<span class="line"><span style="color: #c9d1d9">this.setState((state, props) => ({</span></span>
<span class="line"><span style="color: #c9d1d9">  counter: state.counter + props.increment</span></span>
<span class="line"><span style="color: #c9d1d9">}));</span></span>
<span class="line"><span style="color: #c9d1d9">使用函数，保证这个是一个单例模式。</span></span>
<span class="line"><span style="color: #c9d1d9">vue中为什么data是一个函数。</span></span>
<span class="line"><span style="color: #c9d1d9">将data封装成函数后，在实例化组件的时候，我们只是调用了data函数生成的数据副本，避免了数据污染。</span></span>
<span class="line"><span style="color: #c9d1d9">3.State的更新会被合并。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">4.数据是向下流动的。</span></span>
<span class="line"><span style="color: #c9d1d9">为什么成为state是局部的或是封装的原因。</span></span>
<span class="line"><span style="color: #c9d1d9">因为不论是父组件还是子组件都无法知道某一个组件内部是有状态还是无状态，并且他们不关心他们是函数还是class组件。</span></span>
<span class="line"><span style="color: #c9d1d9">除了拥有并且设置他的组件，其他组件无法访问。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;FormattedDate date={this.state.date} /></span></span>
<span class="line"><span style="color: #c9d1d9">这里FormattedDate组件会在props中接受参数date,但是组件本身无法知道他是来自Clock的state,还是Clock的props,或是手动输入。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="第六章react-事件处理">第六章：React 事件处理</h1>
<h3 id="事件处理的语法">事件处理的语法</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">1.React事件命名使用小驼峰命名，而不是纯小写原生方式</span></span>
<span class="line"><span style="color: #c9d1d9">2.JSX语法中需要传入一个函数作为事件处理函数，而不是一个字符串。</span></span>
<span class="line"><span style="color: #c9d1d9">3.你不能通过return false阻止默认行为，必须显式调用preventDefault,</span></span></code></pre>
<h3 id="向事件处理程序传递参数">向事件处理程序传递参数</h3>
<p>方法 1：箭头函数实现传递，因为如果是箭头函数，事件的对象必须通过显式的方法进行传递</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">&#x3C;button onClick={(e) => this.deleteRow(id, e)}>Delete Row&#x3C;/button></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>方法 2：bind 传递参数，符合我们的常识认知</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;button onClick={this.deleteRow.bind(this, id)}>Delete Row&#x3C;/button></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="第七章条件渲染">第七章：条件渲染</h1>
<h3 id="true--expression-总是会返回-expression">true &#x26;&#x26; expression 总是会返回 expression。</h3>
<p>因为在 JavaScript 中，true &#x26;&#x26; expression 总是会返回 expression, 而 false &#x26;&#x26; expression 总是会返回 false。</p>
<h3 id="阻止组件渲染">阻止组件渲染</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">让 render 方法直接返回 null，而不进行任何渲染。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">```</span></span>
<span class="line"><span style="color: #c9d1d9">function WarningBanner(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">  if (!props.warn) {</span></span>
<span class="line"><span style="color: #c9d1d9">    return null;</span></span>
<span class="line"><span style="color: #c9d1d9">  }</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;div className="warning"></span></span>
<span class="line"><span style="color: #c9d1d9">      Warning!</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;/div></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="第八章列表--key">第八章：列表 &#x26; Key</h1>
<h3 id="key-帮助-react-识别哪些元素改变了比如被添加或删除因此你应当给数组中的每一个元素赋予一个确定的标识">key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</h3>
<p>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key。
如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值。</p>
<h3 id="用-key-提取组件">用 key 提取组件</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">元素的 key 只有放在就近的数组上下文中才有意义。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">错误案例</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">function ListItem(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">  const value = props.value;</span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    // 错误！你不需要在这里指定 key：</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;li key={value.toString()}></span></span>
<span class="line"><span style="color: #c9d1d9">      {value}</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;/li></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">function NumberList(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">  const numbers = props.numbers;</span></span>
<span class="line"><span style="color: #c9d1d9">  const listItems = numbers.map((number) =></span></span>
<span class="line"><span style="color: #c9d1d9">    // 错误！元素的 key 应该在这里指定：</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;ListItem value={number} /></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;ul></span></span>
<span class="line"><span style="color: #c9d1d9">      {listItems}</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;/ul></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">const numbers = [1, 2, 3, 4, 5];</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">正确方法</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">function ListItem(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">  // 正确！这里不需要指定 key：</span></span>
<span class="line"><span style="color: #c9d1d9">  return &#x3C;li>{props.value}&#x3C;/li>;</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">function NumberList(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">  const numbers = props.numbers;</span></span>
<span class="line"><span style="color: #c9d1d9">  const listItems = numbers.map((number) =></span></span>
<span class="line"><span style="color: #c9d1d9">    // 正确！key 应该在数组的上下文中被指定</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;ListItem key={number.toString()}              value={number} /></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;ul></span></span>
<span class="line"><span style="color: #c9d1d9">      {listItems}</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;/ul></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。</span></span></code></pre>
<h3 id="key-只是在兄弟节点之间必须唯一">key 只是在兄弟节点之间必须唯一</h3>
<p>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：</p>
<h3 id="key-会传递信息给-react-但不会传递给你的组件如果你的组件中需要使用-key-属性的值请用其他属性名显式传递这个值">key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：</h3>
<h1 id="第九章在-react-里html-表单元素的工作方式和其他的-dom-元素有些不同">第九章：在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同</h1>
<p>表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称。</p>
<h3 id="受控组件">受控组件</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">HTML 中表单元素：input,textarea,select 等都是自己维护 state,根据用户输入来进行更新。</span></span>
<span class="line"><span style="color: #c9d1d9">React 中可变状态通常保存 state 属性中，只能通过 setState 来更新。</span></span>
<span class="line"><span style="color: #c9d1d9">所以我们可以结合两者，让 React 的 state 成为唯一的数据源。比如原理的 name 赋值使用 this.state</span></span></code></pre>
<h3 id="textarea-标签">textarea 标签</h3>
<p>HTML 中，textarea 元素通过子元素定义其文本。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">&#x3C;textarea></span></span>
<span class="line"><span style="color: #c9d1d9">  你好， 这是在 text area 里的文本</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;/textarea></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<p>React 中使用 value 代替，这样，textarea 的使用和 input 的使用非常相似。</p>
<h3 id="select-标签">select 标签</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">HTML 中，select 创建下拉标签，这里使用 selected 来选择默认选中，</span></span>
<span class="line"><span style="color: #c9d1d9">React 中使用 select 标签的 value 属性，来定义这个选中，在根标签中更新它。</span></span>
<span class="line"><span style="color: #c9d1d9">你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;select multiple={true} value={['B', 'C']}></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h3 id="input-标签">input 标签</h3>
<p>HTML 中 input type=file 允许用户选择文件，但是这里的 value 中只读，所以它是一个非受控组件。</p>
<h3 id="处理多个输入可以给每一个元素添加-name根据函数-eventtargetname-的值选择">处理多个输入，可以给每一个元素添加 name,根据函数 event.target.name 的值选择</h3>
<h3 id="受控组件和非受控组件">受控组件和非受控组件</h3>
<p>在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。
另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</p>
<h4 id="一些外部嵌套-react-的快速-demo使用非受控组件操作-dom">一些外部嵌套 react 的快速 demo,使用非受控组件操作 dom</h4>
<p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，
有时候反而更容易同时集成 React 和非 React 代码。</p>
<h1 id="第十章状态提升">第十章：状态提升</h1>
<p>多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。
在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，
便可实现共享 state。这就是所谓的“状态提升”。</p>
<p>如果可以通过 prop 来推导或是父级数据推断，那么不应该使用 state 定义，而是找到公共的内容一起使用。</p>
<h1 id="第十一章">第十一章</h1>
<p>推荐使用组合而非继承来实现组件间的代码重用。
JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。
在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">function Dialog(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;FancyBorder color="blue"></span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;h1 className="Dialog-title"></span></span>
<span class="line"><span style="color: #c9d1d9">        {props.title}</span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;/h1></span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;p className="Dialog-message"></span></span>
<span class="line"><span style="color: #c9d1d9">        {props.message}</span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;/p></span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;/FancyBorder></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">function WelcomeDialog() {</span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;Dialog</span></span>
<span class="line"><span style="color: #c9d1d9">      title="Welcome"</span></span>
<span class="line"><span style="color: #c9d1d9">      message="Thank you for visiting our spacecraft!" /></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h6 id="props-和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式">Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。</h6>
<p>注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p>
<h4 id="props-和-state-区别">props 和 state 区别</h4>
<p>props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p>
<h1 id="12react-设计哲学">12.React 设计哲学</h1>
<h3 id="第一步将设计好的-ui-分为组件层级">第一步将设计好的 UI 分为组件层级</h3>
<h3 id="第二步搭建基础的静态-ui-页面">第二步搭建基础的静态 UI 页面</h3>
<h3 id="第三步定义数据结构确定-ui-的-state-的最小表示">第三步：定义数据结构，确定 UI 的 state 的最小表示</h3>
<h3 id="第四步确定-state-的设置位置">第四步：确定 state 的设置位置。</h3>
<p>根据 React 中最小实现，放置 state 的使用位置。</p>
<h3 id="第五步添加反向数据流">第五步：添加反向数据流</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">处于较低层级的表单组件更新较高层级的 FilterableProductTable 中的 state。</span></span>
<span class="line"><span style="color: #c9d1d9">我们可以使用输入框的 onChange 事件来监视用户输入的变化，并通知 FilterableProductTable 传递给 SearchBar 的回调函数。然后该回调函数将调用 setState()</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="补充一个小知识">补充一个小知识</h1>
<p>ES6 开始，对象初始值设定项语法还支持计算属性名称。这允许您将表达式放在括号中</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">let config = {</span></span>
<span class="line"><span style="color: #c9d1d9">  [param]: 12,</span></span>
<span class="line"><span style="color: #c9d1d9">  ['mobile' + param.charAt(0).toUpperCase() + param.slice(1)]: 4</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="ref-转发是一项将-ref-自动地通过组件传递到其一子组件的技巧">Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。</h1>
<p>访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。
Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件.</p>
<h3 id="案例">案例</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">const FancyButton = React.forwardRef((props, ref) => (</span></span>
<span class="line"><span style="color: #c9d1d9">  &#x3C;button ref={ref} className="FancyButton"></span></span>
<span class="line"><span style="color: #c9d1d9">    {props.children}</span></span>
<span class="line"><span style="color: #c9d1d9">  &#x3C;/button></span></span>
<span class="line"><span style="color: #c9d1d9">));</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">// 你可以直接获取 DOM button 的 ref：</span></span>
<span class="line"><span style="color: #c9d1d9">const ref = React.createRef();</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;FancyButton ref={ref}>Click me!&#x3C;/FancyButton>;</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">当 ref 挂载完成，ref.current 将指向 &#x3C;button> DOM 节点。</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="注意自动绑定如何-class-中的方法自动绑定-this">注意自动绑定，如何 class 中的方法自动绑定 this</h1>
<h4 id="手动绑定-this">手动绑定 this</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">一般而言，class 创建的组件需要在 constructor 中显式绑定 this,.bind(this).</span></span>
<span class="line"><span style="color: #c9d1d9">constructor(props) {</span></span>
<span class="line"><span style="color: #c9d1d9">super(props);</span></span>
<span class="line"><span style="color: #c9d1d9">this.state = {message: 'Hello!'};</span></span>
<span class="line"><span style="color: #c9d1d9">// 这一行很重要！</span></span>
<span class="line"><span style="color: #c9d1d9">this.handleClick = this.handleClick.bind(this);</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="自定实现组件的绑定-this">自定实现组件的绑定 this</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">如果使用 createReactClass() 方法创建组件，组件中的方法会自动绑定至实例，所以不需要像上面那样做：</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">var SayHello = createReactClass({</span></span>
<span class="line"><span style="color: #c9d1d9">getInitialState: function() {</span></span>
<span class="line"><span style="color: #c9d1d9">return {message: 'Hello!'};</span></span>
<span class="line"><span style="color: #c9d1d9">},</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">handleClick: function() {</span></span>
<span class="line"><span style="color: #c9d1d9">alert(this.state.message);</span></span>
<span class="line"><span style="color: #c9d1d9">},</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">render: function() {</span></span>
<span class="line"><span style="color: #c9d1d9">return (</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;button onClick={this.handleClick}></span></span>
<span class="line"><span style="color: #c9d1d9">Say hello</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;/button></span></span>
<span class="line"><span style="color: #c9d1d9">);</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9">});</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="fragments">Fragments</h1>
<p>React 中的一个常见模式是一个组件返回多个元素。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">render() {</span></span>
<span class="line"><span style="color: #c9d1d9">  return (</span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;React.Fragment></span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;ChildA /></span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;ChildB /></span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;ChildC /></span></span>
<span class="line"><span style="color: #c9d1d9">    &#x3C;/React.Fragment></span></span>
<span class="line"><span style="color: #c9d1d9">  );</span></span>
<span class="line"><span style="color: #c9d1d9">}</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h4 id="另外一种短语法则">另外一种短语法则</h4>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">return (</span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;></span></span>
<span class="line"><span style="color: #c9d1d9">        &#x3C;td>Hello&#x3C;/td></span></span>
<span class="line"><span style="color: #c9d1d9">        &#x3C;td>World&#x3C;/td></span></span>
<span class="line"><span style="color: #c9d1d9">      &#x3C;/></span></span>
<span class="line"><span style="color: #c9d1d9">    );</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h1 id="代码分割">代码分割</h1>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">在你的应用中引入代码分割的最佳方式是通过动态 import() 语法。</span></span></code></pre>
<h3 id="使用之前案例">使用之前案例</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">import { add } from './math';</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">console.log(add(16, 26));</span></span></code></pre>
<h3 id="使用之后案例">使用之后案例</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9">import("./math").then(math => {</span></span>
<span class="line"><span style="color: #c9d1d9">  console.log(math.add(16, 26));</span></span>
<span class="line"><span style="color: #c9d1d9">});</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span></code></pre>
<h3 id="代码懒加载-lazy">代码懒加载 lazy</h3>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">const OtherComponent = React.lazy(() => import('./OtherComponent'));</span></span>
<span class="line"><span style="color: #c9d1d9">import React, { lazy } from 'react';</span></span>
<span class="line"><span style="color: #c9d1d9">const MyComponent = lazy(() => import("./MyComponent.js"));</span></span></code></pre>
<h1 id="深入-jsx">深入 JSX</h1>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">实际上，jsx 只是 React.createElement（component,props,...children）的函数语法糖</span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">olor="blue" shadowSize={2}></span></span>
<span class="line"><span style="color: #c9d1d9">  Click Me</span></span>
<span class="line"><span style="color: #c9d1d9">&#x3C;/MyButton></span></span>
<span class="line"><span style="color: #c9d1d9"></span></span>
<span class="line"><span style="color: #c9d1d9">编译结果</span></span>
<span class="line"><span style="color: #c9d1d9">React.createElement(</span></span>
<span class="line"><span style="color: #c9d1d9">  MyButton,</span></span>
<span class="line"><span style="color: #c9d1d9">  {color: 'blue', shadowSize: 2},</span></span>
<span class="line"><span style="color: #c9d1d9">  'Click Me'</span></span>
<span class="line"><span style="color: #c9d1d9">)</span></span></code></pre>
<h3 id="jsx-类型中使用点语法">JSX 类型中使用点语法</h3>
<h3 id="用户定义的组件必须以大写字母开头">用户定义的组件必须以大写字母开头</h3>
<h1 id="高阶组件-hoc-暂停">高阶组件 HOC 暂停</h1>
<p>高阶组件就是参数为组件，返回值为新组件的函数。
组件是将 props 转换为 UI,高阶组件是将组件转换为另一个组件。</p>
<h3 id="hoc-常见的高阶组件">HOC 常见的高阶组件</h3>
<p>Redux 的 connect 是高阶组件
Relay 的 createFramentContainer 是高阶组件</p>
<h3 id="组件是-react-中代码复用的基本单元但是某些模式下不适合传统组件">组件是 React 中代码复用的基本单元，但是某些模式下，不适合传统组件。</h3>
<h4 id="案例学习commentlist-组件订阅外部数据源渲染评论列表">案例学习：commentlist 组件，订阅外部数据源，渲染评论列表</h4>
  </section>
  <nav class="block sm:hidden astro-J75B3YUS">
    <h2 class="heading astro-BYIKQF6W">More</h2>
<ul class="astro-BYIKQF6W">
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a class="edit-on-github astro-BYIKQF6W" href="https://github.com/nyhxiaoning/nyhxiaoning.github.io/blob/master/src/content/docs/en/07react%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/001%E5%9F%BA%E7%A1%80react%E7%AC%94%E8%AE%B0%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95.md" target="_blank">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="pen" class="svg-inline--fa fa-pen fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Edit this page</span>
				</a>
			</li>
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a href="https://astro.build/chat" target="_blank" class="astro-BYIKQF6W">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="comment-alt" class="svg-inline--fa fa-comment-alt fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 9.8 11.2 15.5 19.1 9.7L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Join our community</span>
				</a>
			</li>
</ul>
<div style="margin: 2rem 0; text-align: center;" class="astro-BYIKQF6W">
	<script>(self.Astro=self.Astro||{}).visible=(s,c,n)=>{const r=async()=>{await(await s())()};let i=new IntersectionObserver(e=>{for(const t of e)if(!!t.isIntersecting){i.disconnect(),r();break}});for(let e=0;e<n.children.length;e++){const t=n.children[e];i.observe(t)}},window.dispatchEvent(new Event("astro:visible"));</script><astro-island uid="Ofjlz" component-url="/_astro/ThemeToggleButton.7f5d5bf2.js" component-export="default" renderer-url="/_astro/client.2b526cb2.js" props="{&quot;class&quot;:[0,&quot;astro-BYIKQF6W&quot;]}" ssr="" client="visible" opts="{&quot;name&quot;:&quot;ThemeToggleButton&quot;,&quot;value&quot;:true}" await-children=""><div class="theme-toggle"><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clipRule="evenodd"></path></svg><input type="radio" name="theme-toggle" value="light" title="Use light theme" aria-label="Use light theme" /></label><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg><input type="radio" name="theme-toggle" value="dark" title="Use dark theme" aria-label="Use dark theme" /></label></div></astro-island>
</div>
  </nav>
</article>
<script>
  console.log(window.location.href);
  let currentRoute = decodeURIComponent(window.location.href).split("/")[
    decodeURIComponent(window.location.href).split("/").length - 2
  ];
  const menuData = {
    "0个人前端项目实战记录和链接": 0,
    "0经典脚手架持续迭代": 1,
    "01react课程学习和问题笔记": 2,
    "02极客时间vue课程学习和问题笔记": 3,
    "03掘金算法课程学习和问题笔记": 4,
    "04小程序专题": 5,
    "05leetcode刷题记录每周": 6,
    "06node全栈记录": 7,
    "07react学习常见问题和笔记记录": 8,
    "08vue常见问题和学习记录": 9,
    "09book前端进阶知识学习图书笔记": 10,
    "10book前端开发设计模式和开发实战笔记": 11,
    "11elementplus经典源码和实战学习和问题笔记": 12,
    "12前端开发经典库学习记录": 13,
    "13koa和express框架学习记录": 14,
    "14前端图形化学习": 15,
    "15工具和项目配置工程化问题记录": 16,
    "16前端拓展知识学习": 17,
    "17低代码学习和总结": 18,
    "18经验亮点汇总汇总": 19,
    "19项目复盘汇总": 20,
    其他常见问题: 21,
  };

  window.addEventListener("DOMContentLoaded", () => {
    var target = document.querySelector('[aria-current="page"]');
    if (target && target.offsetTop > window.innerHeight - 100) {
      document.querySelector(".nav-groups").scrollTop = target.offsetTop;
    }
  });
  debugger;
  // TODO:根据当前的选中的路由的名称，反转成路由菜单
  console.log("%s 当前的值💡 ");
  console.log(
    "%c💡 当前的最新打印，用完删除",
    "background-color:blue;color:#fff"
  );
  let testDiv = document.getElementsByClassName("nav-group astro-KQNE5HRN")[0];
  testDiv.getElementsByTagName("ul")[0].children[menuData[currentRoute]].style =
    "color: rgb(56,149,255);font-weight:700;background:rgb(225,239,255)";
</script>
      </div>
      <aside id="grid-right" class="grid-sidebar astro-OUAMJN2I" title="Table of Contents">
        <nav class="sidebar-nav astro-ROIVMLUZ" aria-labelledby="grid-right">
	<div class="sidebar-nav-inner astro-ROIVMLUZ">
		<astro-island uid="ZqM3au" component-url="/_astro/TableOfContents.3058fe45.js" component-export="default" renderer-url="/_astro/client.2b526cb2.js" props="{&quot;headings&quot;:[1,&quot;[[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;一些常见使用习惯\&quot;],\&quot;text\&quot;:[0,\&quot;一些常见使用习惯\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;组件的开发必须使用大驼峰命名\&quot;],\&quot;text\&quot;:[0,\&quot;组件的开发必须使用大驼峰命名\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;jsx-使用说明习惯\&quot;],\&quot;text\&quot;:[0,\&quot;jsx 使用说明习惯\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;classname\&quot;],\&quot;text\&quot;:[0,\&quot;className\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;所有-react-组件都必须像纯函数一样保护它们的-props-不被更改\&quot;],\&quot;text\&quot;:[0,\&quot;所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;jsx-中写注释括起来\&quot;],\&quot;text\&quot;:[0,\&quot;jsx 中写注释：${}括起来\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;jsx-中自定义组件名称必须以大写字母开头\&quot;],\&quot;text\&quot;:[0,\&quot;jsx 中自定义组件名称必须以大写字母开头。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;reactdom-渲染前默认将输入所有的内容进行转义\&quot;],\&quot;text\&quot;:[0,\&quot;ReactDom 渲染前，默认将输入所有的内容进行转义。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;避免将-props-的值复制给-state这是一个常见的错误\&quot;],\&quot;text\&quot;:[0,\&quot;避免将 props 的值复制给 state！这是一个常见的错误：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;componentdidupdate必须注意它必须被包裹在一个条件语句里\&quot;],\&quot;text\&quot;:[0,\&quot;componentDidUpdate()必须注意它必须被包裹在一个条件语句里\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;一般-react-构建的应用通常只有单一的根-dom-节点\&quot;],\&quot;text\&quot;:[0,\&quot;一般 React 构建的应用通常只有单一的根 DOM 节点。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;1jsx-转换使用特定属性值\&quot;],\&quot;text\&quot;:[0,\&quot;1.jsx 转换使用特定属性值\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第三章元素渲染\&quot;],\&quot;text\&quot;:[0,\&quot;第三章：元素渲染\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;1更新已经渲染的元素\&quot;],\&quot;text\&quot;:[0,\&quot;1.更新已经渲染的元素\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;2react-只更新它需要更新的部分\&quot;],\&quot;text\&quot;:[0,\&quot;2.React 只更新它需要更新的部分\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第四章组件和-pops\&quot;],\&quot;text\&quot;:[0,\&quot;第四章：组件和 Pops\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;函数组件和-class-组件\&quot;],\&quot;text\&quot;:[0,\&quot;函数组件和 class 组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;js-函数定义一个函数组件\&quot;],\&quot;text\&quot;:[0,\&quot;js 函数定义一个函数组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;class-组件\&quot;],\&quot;text\&quot;:[0,\&quot;class 组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;渲染组件\&quot;],\&quot;text\&quot;:[0,\&quot;渲染组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;props-的只读性\&quot;],\&quot;text\&quot;:[0,\&quot;props 的只读性\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;5state-和生命周期\&quot;],\&quot;text\&quot;:[0,\&quot;5.state 和生命周期\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;组件的生命周期\&quot;],\&quot;text\&quot;:[0,\&quot;组件的生命周期\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;当组件实例被创建并插入-dom-中时其生命周期调用顺序如下\&quot;],\&quot;text\&quot;:[0,\&quot;当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;组件更新时调用顺序\&quot;],\&quot;text\&quot;:[0,\&quot;组件更新时，调用顺序\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;当然这些所有的都是手动的调用和-vue-一样如果只是确保一些单一的功能可以调用必要的\&quot;],\&quot;text\&quot;:[0,\&quot;当然这些所有的都是手动的调用（和 vue 一样，如果只是确保一些单一的功能，可以调用必要的）\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;重复调用相同的值有一个类似-vue-的计算属性-memoization-帮助函数来阻止非必要的过滤\&quot;],\&quot;text\&quot;:[0,\&quot;重复调用相同的值，有一个类似 vue 的计算属性， memoization 帮助函数来阻止非必要的过滤：\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;组件卸载调用方法\&quot;],\&quot;text\&quot;:[0,\&quot;组件卸载调用方法\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;错误处理\&quot;],\&quot;text\&quot;:[0,\&quot;错误处理\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;总的来说-react-分为两大阶段render-阶段和-commit-阶段常用如下\&quot;],\&quot;text\&quot;:[0,\&quot;总的来说 React 分为两大阶段：render 阶段和 commit 阶段（常用如下）\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;函数组件转换为-class-组件\&quot;],\&quot;text\&quot;:[0,\&quot;函数组件转换为 class 组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;向-class-中添加局部的-state\&quot;],\&quot;text\&quot;:[0,\&quot;向 class 中添加局部的 state\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;将生命周期方法添加到-class\&quot;],\&quot;text\&quot;:[0,\&quot;将生命周期方法添加到 class\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;正确的使用-state\&quot;],\&quot;text\&quot;:[0,\&quot;正确的使用 State\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第六章react-事件处理\&quot;],\&quot;text\&quot;:[0,\&quot;第六章：React 事件处理\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;事件处理的语法\&quot;],\&quot;text\&quot;:[0,\&quot;事件处理的语法\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;向事件处理程序传递参数\&quot;],\&quot;text\&quot;:[0,\&quot;向事件处理程序传递参数\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第七章条件渲染\&quot;],\&quot;text\&quot;:[0,\&quot;第七章：条件渲染\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;true--expression-总是会返回-expression\&quot;],\&quot;text\&quot;:[0,\&quot;true &amp;&amp; expression 总是会返回 expression。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;阻止组件渲染\&quot;],\&quot;text\&quot;:[0,\&quot;阻止组件渲染\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第八章列表--key\&quot;],\&quot;text\&quot;:[0,\&quot;第八章：列表 &amp; Key\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;key-帮助-react-识别哪些元素改变了比如被添加或删除因此你应当给数组中的每一个元素赋予一个确定的标识\&quot;],\&quot;text\&quot;:[0,\&quot;key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;用-key-提取组件\&quot;],\&quot;text\&quot;:[0,\&quot;用 key 提取组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;key-只是在兄弟节点之间必须唯一\&quot;],\&quot;text\&quot;:[0,\&quot;key 只是在兄弟节点之间必须唯一\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;key-会传递信息给-react-但不会传递给你的组件如果你的组件中需要使用-key-属性的值请用其他属性名显式传递这个值\&quot;],\&quot;text\&quot;:[0,\&quot;key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第九章在-react-里html-表单元素的工作方式和其他的-dom-元素有些不同\&quot;],\&quot;text\&quot;:[0,\&quot;第九章：在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;受控组件\&quot;],\&quot;text\&quot;:[0,\&quot;受控组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;textarea-标签\&quot;],\&quot;text\&quot;:[0,\&quot;textarea 标签\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;select-标签\&quot;],\&quot;text\&quot;:[0,\&quot;select 标签\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;input-标签\&quot;],\&quot;text\&quot;:[0,\&quot;input 标签\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;处理多个输入可以给每一个元素添加-name根据函数-eventtargetname-的值选择\&quot;],\&quot;text\&quot;:[0,\&quot;处理多个输入，可以给每一个元素添加 name,根据函数 event.target.name 的值选择\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;受控组件和非受控组件\&quot;],\&quot;text\&quot;:[0,\&quot;受控组件和非受控组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;一些外部嵌套-react-的快速-demo使用非受控组件操作-dom\&quot;],\&quot;text\&quot;:[0,\&quot;一些外部嵌套 react 的快速 demo,使用非受控组件操作 dom\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第十章状态提升\&quot;],\&quot;text\&quot;:[0,\&quot;第十章：状态提升\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;第十一章\&quot;],\&quot;text\&quot;:[0,\&quot;第十一章\&quot;]}],[0,{\&quot;depth\&quot;:[0,6],\&quot;slug\&quot;:[0,\&quot;props-和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式\&quot;],\&quot;text\&quot;:[0,\&quot;Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;props-和-state-区别\&quot;],\&quot;text\&quot;:[0,\&quot;props 和 state 区别\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;12react-设计哲学\&quot;],\&quot;text\&quot;:[0,\&quot;12.React 设计哲学\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第一步将设计好的-ui-分为组件层级\&quot;],\&quot;text\&quot;:[0,\&quot;第一步将设计好的 UI 分为组件层级\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第二步搭建基础的静态-ui-页面\&quot;],\&quot;text\&quot;:[0,\&quot;第二步搭建基础的静态 UI 页面\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第三步定义数据结构确定-ui-的-state-的最小表示\&quot;],\&quot;text\&quot;:[0,\&quot;第三步：定义数据结构，确定 UI 的 state 的最小表示\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第四步确定-state-的设置位置\&quot;],\&quot;text\&quot;:[0,\&quot;第四步：确定 state 的设置位置。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;第五步添加反向数据流\&quot;],\&quot;text\&quot;:[0,\&quot;第五步：添加反向数据流\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;补充一个小知识\&quot;],\&quot;text\&quot;:[0,\&quot;补充一个小知识\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;ref-转发是一项将-ref-自动地通过组件传递到其一子组件的技巧\&quot;],\&quot;text\&quot;:[0,\&quot;Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;案例\&quot;],\&quot;text\&quot;:[0,\&quot;案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;注意自动绑定如何-class-中的方法自动绑定-this\&quot;],\&quot;text\&quot;:[0,\&quot;注意自动绑定，如何 class 中的方法自动绑定 this\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;手动绑定-this\&quot;],\&quot;text\&quot;:[0,\&quot;手动绑定 this\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;自定实现组件的绑定-this\&quot;],\&quot;text\&quot;:[0,\&quot;自定实现组件的绑定 this\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;fragments\&quot;],\&quot;text\&quot;:[0,\&quot;Fragments\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;另外一种短语法则\&quot;],\&quot;text\&quot;:[0,\&quot;另外一种短语法则\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;代码分割\&quot;],\&quot;text\&quot;:[0,\&quot;代码分割\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;使用之前案例\&quot;],\&quot;text\&quot;:[0,\&quot;使用之前案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;使用之后案例\&quot;],\&quot;text\&quot;:[0,\&quot;使用之后案例\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;代码懒加载-lazy\&quot;],\&quot;text\&quot;:[0,\&quot;代码懒加载 lazy\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;深入-jsx\&quot;],\&quot;text\&quot;:[0,\&quot;深入 JSX\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;jsx-类型中使用点语法\&quot;],\&quot;text\&quot;:[0,\&quot;JSX 类型中使用点语法\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;用户定义的组件必须以大写字母开头\&quot;],\&quot;text\&quot;:[0,\&quot;用户定义的组件必须以大写字母开头\&quot;]}],[0,{\&quot;depth\&quot;:[0,1],\&quot;slug\&quot;:[0,\&quot;高阶组件-hoc-暂停\&quot;],\&quot;text\&quot;:[0,\&quot;高阶组件 HOC 暂停\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;hoc-常见的高阶组件\&quot;],\&quot;text\&quot;:[0,\&quot;HOC 常见的高阶组件\&quot;]}],[0,{\&quot;depth\&quot;:[0,3],\&quot;slug\&quot;:[0,\&quot;组件是-react-中代码复用的基本单元但是某些模式下不适合传统组件\&quot;],\&quot;text\&quot;:[0,\&quot;组件是 React 中代码复用的基本单元，但是某些模式下，不适合传统组件。\&quot;]}],[0,{\&quot;depth\&quot;:[0,4],\&quot;slug\&quot;:[0,\&quot;案例学习commentlist-组件订阅外部数据源渲染评论列表\&quot;],\&quot;text\&quot;:[0,\&quot;案例学习：commentlist 组件，订阅外部数据源，渲染评论列表\&quot;]}]]&quot;],&quot;class&quot;:[0,&quot;astro-ROIVMLUZ&quot;]}" ssr="" client="media" opts="{&quot;name&quot;:&quot;TableOfContents&quot;,&quot;value&quot;:&quot;(min-width: 50em)&quot;}" await-children=""><h2 id="on-this-page-heading" class="heading">目录</h2><ul><li class="header-link depth-3"><a href="#一些常见使用习惯">一些常见使用习惯</a></li><li class="header-link depth-3"><a href="#1jsx-转换使用特定属性值">1.jsx 转换使用特定属性值</a></li><li class="header-link depth-3"><a href="#1更新已经渲染的元素">1.更新已经渲染的元素</a></li><li class="header-link depth-3"><a href="#2react-只更新它需要更新的部分">2.React 只更新它需要更新的部分</a></li><li class="header-link depth-3"><a href="#函数组件和-class-组件">函数组件和 class 组件</a></li><li class="header-link depth-3"><a href="#渲染组件">渲染组件</a></li><li class="header-link depth-3"><a href="#props-的只读性">props 的只读性</a></li><li class="header-link depth-3"><a href="#组件的生命周期">组件的生命周期</a></li><li class="header-link depth-3"><a href="#正确的使用-state">正确的使用 State</a></li><li class="header-link depth-3"><a href="#事件处理的语法">事件处理的语法</a></li><li class="header-link depth-3"><a href="#向事件处理程序传递参数">向事件处理程序传递参数</a></li><li class="header-link depth-3"><a href="#true--expression-总是会返回-expression">true &amp;&amp; expression 总是会返回 expression。</a></li><li class="header-link depth-3"><a href="#阻止组件渲染">阻止组件渲染</a></li><li class="header-link depth-3"><a href="#key-帮助-react-识别哪些元素改变了比如被添加或删除因此你应当给数组中的每一个元素赋予一个确定的标识">key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。</a></li><li class="header-link depth-3"><a href="#用-key-提取组件">用 key 提取组件</a></li><li class="header-link depth-3"><a href="#key-只是在兄弟节点之间必须唯一">key 只是在兄弟节点之间必须唯一</a></li><li class="header-link depth-3"><a href="#key-会传递信息给-react-但不会传递给你的组件如果你的组件中需要使用-key-属性的值请用其他属性名显式传递这个值">key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：</a></li><li class="header-link depth-3"><a href="#受控组件">受控组件</a></li><li class="header-link depth-3"><a href="#textarea-标签">textarea 标签</a></li><li class="header-link depth-3"><a href="#select-标签">select 标签</a></li><li class="header-link depth-3"><a href="#input-标签">input 标签</a></li><li class="header-link depth-3"><a href="#处理多个输入可以给每一个元素添加-name根据函数-eventtargetname-的值选择">处理多个输入，可以给每一个元素添加 name,根据函数 event.target.name 的值选择</a></li><li class="header-link depth-3"><a href="#受控组件和非受控组件">受控组件和非受控组件</a></li><li class="header-link depth-3"><a href="#第一步将设计好的-ui-分为组件层级">第一步将设计好的 UI 分为组件层级</a></li><li class="header-link depth-3"><a href="#第二步搭建基础的静态-ui-页面">第二步搭建基础的静态 UI 页面</a></li><li class="header-link depth-3"><a href="#第三步定义数据结构确定-ui-的-state-的最小表示">第三步：定义数据结构，确定 UI 的 state 的最小表示</a></li><li class="header-link depth-3"><a href="#第四步确定-state-的设置位置">第四步：确定 state 的设置位置。</a></li><li class="header-link depth-3"><a href="#第五步添加反向数据流">第五步：添加反向数据流</a></li><li class="header-link depth-3"><a href="#案例">案例</a></li><li class="header-link depth-3"><a href="#使用之前案例">使用之前案例</a></li><li class="header-link depth-3"><a href="#使用之后案例">使用之后案例</a></li><li class="header-link depth-3"><a href="#代码懒加载-lazy">代码懒加载 lazy</a></li><li class="header-link depth-3"><a href="#jsx-类型中使用点语法">JSX 类型中使用点语法</a></li><li class="header-link depth-3"><a href="#用户定义的组件必须以大写字母开头">用户定义的组件必须以大写字母开头</a></li><li class="header-link depth-3"><a href="#hoc-常见的高阶组件">HOC 常见的高阶组件</a></li><li class="header-link depth-3"><a href="#组件是-react-中代码复用的基本单元但是某些模式下不适合传统组件">组件是 React 中代码复用的基本单元，但是某些模式下，不适合传统组件。</a></li></ul></astro-island>
		<h2 class="heading astro-BYIKQF6W">More</h2>
<ul class="astro-BYIKQF6W">
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a class="edit-on-github astro-BYIKQF6W" href="https://github.com/nyhxiaoning/nyhxiaoning.github.io/blob/master/src/content/docs/en/07react%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95/001%E5%9F%BA%E7%A1%80react%E7%AC%94%E8%AE%B0%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95.md" target="_blank">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="pen" class="svg-inline--fa fa-pen fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Edit this page</span>
				</a>
			</li>
	<li class="header-link depth-2 astro-BYIKQF6W">
				<a href="https://astro.build/chat" target="_blank" class="astro-BYIKQF6W">
					<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="comment-alt" class="svg-inline--fa fa-comment-alt fa-w-16 astro-BYIKQF6W" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="1em" width="1em">
						<path fill="currentColor" d="M448 0H64C28.7 0 0 28.7 0 64v288c0 35.3 28.7 64 64 64h96v84c0 9.8 11.2 15.5 19.1 9.7L304 416h144c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64z" class="astro-BYIKQF6W"></path>
					</svg>
					<span class="astro-BYIKQF6W">Join our community</span>
				</a>
			</li>
</ul>
<div style="margin: 2rem 0; text-align: center;" class="astro-BYIKQF6W">
	<astro-island uid="Ofjlz" component-url="/_astro/ThemeToggleButton.7f5d5bf2.js" component-export="default" renderer-url="/_astro/client.2b526cb2.js" props="{&quot;class&quot;:[0,&quot;astro-BYIKQF6W&quot;]}" ssr="" client="visible" opts="{&quot;name&quot;:&quot;ThemeToggleButton&quot;,&quot;value&quot;:true}" await-children=""><div class="theme-toggle"><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clipRule="evenodd"></path></svg><input type="radio" name="theme-toggle" value="light" title="Use light theme" aria-label="Use light theme" /></label><label class><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg><input type="radio" name="theme-toggle" value="dark" title="Use dark theme" aria-label="Use dark theme" /></label></div></astro-island>
</div>
	</div>
</nav>
      </aside>
    </main>
    <!-- <footer> --><!-- <AvatarList path={path} /> --><!-- </footer> -->
  </body></html>