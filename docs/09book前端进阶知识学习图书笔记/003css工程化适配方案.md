[[toc]]

mobile.width = 750px => 750px = 100% =100vw => 750px = 100vw
=> 1px = 0.1333vw =>
100px = 13.33vw =>

得出：
移动端的尺寸 / 100 = XXX rem；

这里大概

## 001 移动端自适应的适应方案：rem 和 vw

这里两种实现方案

### 1.第一种 flexmin.js 适配

```
(function (win, lib) {
    var doc = win.document;
    var docEl = doc.documentElement;
    var metaEl = doc.querySelector('meta[name="viewport"]');
    var flexibleEl = doc.querySelector('meta[name="flexible"]');
    var dpr = 0;
    var scale = 0;
    var tid;
    var flexible = lib.flexible || (lib.flexible = {});

    if (metaEl) {
        console.warn("将根据已有的meta标签来设置缩放比例");
        var match = metaEl
            .getAttribute("content")
            // eslint-disable-next-line no-useless-escape
            .match(/initial\-scale=([\d\.]+)/);
        if (match) {
            scale = parseFloat(match[1]);
            dpr = parseInt(1 / scale);
        }
    } else if (flexibleEl) {
        var content = flexibleEl.getAttribute("content");
        if (content) {
            // eslint-disable-next-line no-useless-escape
            var initialDpr = content.match(/initial\-dpr=([\d\.]+)/);
            // eslint-disable-next-line no-useless-escape
            var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/);
            if (initialDpr) {
                dpr = parseFloat(initialDpr[1]);
                scale = parseFloat((1 / dpr).toFixed(2));
            }
            if (maximumDpr) {
                dpr = parseFloat(maximumDpr[1]);
                scale = parseFloat((1 / dpr).toFixed(2));
            }
        }
    }

    if (!dpr && !scale) {
        // eslint-disable-next-line no-unused-vars
        var isAndroid = win.navigator.appVersion.match(/android/gi);
        var isIPhone = win.navigator.appVersion.match(/iphone/gi);
        var devicePixelRatio = win.devicePixelRatio;
        if (isIPhone) {
            // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案
            if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {
                dpr = 3;
            } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)) {
                dpr = 2;
            } else {
                dpr = 1;
            }
        } else {
            // 其他设备下，仍旧使用1倍的方案
            dpr = 1;
        }
        scale = 1 / dpr;
    }

    docEl.setAttribute("data-dpr", dpr);
    if (!metaEl) {
        metaEl = doc.createElement("meta");
        metaEl.setAttribute("name", "viewport");
        metaEl.setAttribute(
            "content",
            "initial-scale=" +
            scale +
            ", maximum-scale=" +
            scale +
            ", minimum-scale=" +
            scale +
            ", user-scalable=no"
        );
        if (docEl.firstElementChild) {
            docEl.firstElementChild.appendChild(metaEl);
        } else {
            var wrap = doc.createElement("div");
            wrap.appendChild(metaEl);
            doc.write(wrap.innerHTML);
        }
    }

    function refreshRem() {
        var width = docEl.getBoundingClientRect().width;
        // 最小1366px，最大适配2560px
        if (width / dpr < 1366) {
            width = 1366 * dpr;
        } else if (width / dpr > 2560) {
            width = 2560 * dpr;
        }
        // 设置成24等份，设计稿时1920px的，这样1rem就是80px
        var rem = width / 24;
        docEl.style.fontSize = rem + "px";
        flexible.rem = win.rem = rem;
    }

    win.addEventListener(
        "resize",
        function () {
            clearTimeout(tid);
            tid = setTimeout(refreshRem, 300);
        },
        false
    );
    win.addEventListener(
        "pageshow",
        function (e) {
            if (e.persisted) {
                clearTimeout(tid);
                tid = setTimeout(refreshRem, 300);
            }
        },
        false
    );

    if (doc.readyState === "complete") {
        doc.body.style.fontSize = 12 * dpr + "px";
    } else {
        doc.addEventListener(
            "DOMContentLoaded",
            // eslint-disable-next-line no-unused-vars
            function (e) {
                doc.body.style.fontSize = 12 * dpr + "px";
            },
            false
        );
    }

    refreshRem();

    flexible.dpr = win.dpr = dpr;
    flexible.refreshRem = refreshRem;
    flexible.rem2px = function (d) {
        var val = parseFloat(d) * this.rem;
        if (typeof d === "string" && d.match(/rem$/)) {
            val += "px";
        }
        return val;
    };
    flexible.px2rem = function (d) {
        var val = parseFloat(d) / this.rem;
        if (typeof d === "string" && d.match(/px$/)) {
            val += "rem";
        }
        return val;
    };
})(window, window["lib"] || (window["lib"] = {}));
```

导入这个包项目中即可：main.js 中

### 2.postcss-to-viewport

需要安装 webpack loaderpostcss-loader 才能使用 postcss 中的插件对 css 进行处理

less-loader 使用 7.0.2 和 postcss-to-viewport 合作
备注：vant 组件库，建议使用预编译 less，因为源码底层实现是 less,antD 也是 less。
统一样式预处理器，或是只用 css。

成功案例
https://gitee.com/nyhxiaoning/person-xt-phone-base-vuecli3.git

## 3.rem 和 vw 布局对比和响应式方案实现

- 实现响应式手机展示：方法 1:这种因为 rem 布局，
  缺点：弊端之一：和根元素 font-size 值强耦合，系统字体放大或缩小时，会导致布局错乱；
  弊端之二：html 文件头部需插入一段 js 代码
  优点：rem 的优点：移动端 rem 布局比 vw 主流的原因 兼容性
  vw 单位兼容性比 rem 稍差，ios8、安卓 4.4 及以上才完全支持
- 实现响应式手机展示：方法 2：vw vh 固定按照 viewport 来计算，不会受父元素宽高度影响
  页面滚动条属于 viewport 范围内，100vw 当然包括了页面滚动条宽度，而 100%不包含滚动条

## 4.PC 端出现 vw 布局的滚动条后，消除的思路：

TODO:PC 端的布局：引发一个问题：pc 端使用 vw 单位时，如果页面内容超出一屏长度，出现了纵向滚动条，同时有元素 width:100vw， 则会导致出现条横向滚动条
移动端滚动条不占位，所以不会有这个问题）不过 pc 端一般不需要弹性布局，还是尽量使用 width:100%更保险。
当然使用 vw 也可以，消除纵向滚动条的方式： margin-right: calc(100% - 100vw);
