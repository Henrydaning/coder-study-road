![成长](/images/home.png)

[[toc]]

## 回到博客主页

[前端工程化vite和webpack,bael,eslint汇总processOn]([001---前端工程化系统梳理 ProcessOn Mind](https://www.processon.com/mindmap/617781871efad44894fbe29d))

~~~
核心部分
---一个比上面更全面的文章可以看看：webpack2 + vue2 老项目迁移 vite 成功
---webpack打包原理
---vite和webpack
---webpack中的hash三种模式

~~~



[博客首页](./../README.md)  



## 000脚手架工具的选型和使用
### 脚手架的核心学习就亮点：bin字段的使用理解和download-git-repo下载器的正常使用

脚手架地址：
[cli脚手架参考地址](https://gitee.com/nyhxiaoning/cli-template.git)
注意：按照下面的开发计划不能展示：需要全局安装一个这个：npm-package-privatify,为了生成全局的可执行文件，添加到命令行下面执行命令。
否则js脚本项目无法通过命令行执行。
（）
[npm-package-privatify](一个将私有源npm包处理为离线包的自动化工具)

### 目前自己有两个脚手架
- cli-create-template准备修改优化一下这个包

- henry-cli-creator---这个可以使用
~~~
- henry-template-cli---这个需要自己npm run build后才能使用，废弃
~~~
## 如何npm发布一个包

npm login的时候，nrm切换到npm的镜像源地址。

第二：出现下面校验，使用方法登录npm网站，点击account
npm ERR! This operation requires a one-time password from your authenticator.

然后自己选择npm内部的双因子认证登录，避免丢失。
自己下载authenticator后，扫描即可。

npm publish后，发现错误说，你不能发布名为lib的包，意思是重名了。

### You do not have permission to publish "henry-cli". Are you logged in as the correct user?
更换包名即可：package.json的name名称修改


### 尝试发布三个包：
第一个是：[cli脚手架参考地址](https://gitee.com/nyhxiaoning/cli-template.git)

第二个是：
### 脚手架二次封装原因

因为作为开发，已经从接触了vue2,eslint,prettier,ts,webpack,vite,react这些框架的太多大家已经有了最优实现，可以快速在项目中使用。

因此内置脚手架可以最大限度的实现提效。这样每一次的项目创建，可以最快的使用历史上的最优代码，而不是通过各种代码的删减，粘贴和测试，在初始化标准工程上再花费太多时间，使用业界的ts+eslint+prettier+ts作为校验工具，同时各种最优的实现库：比如ts封装的axios库，比如vue3的组件库框架，比如最新的vue-request，vueUse，自动导入组件工具，monorepo实现等等这些框架和技术都是前辈和自己历经bug的结果，所以沉淀下来，可以快速作为新的起点，而且这个起点经得住考验。



### 脚手架基本使用了以下几个工具插件，功能说明了，利用这些组件进行交互



都说站在巨人的肩膀上，一个好的包能让你事半功倍，搭建一个基础的脚手架需要依赖以下包
| 包名 | 用途 |
| --- | --- |
| commander |  命令行工具，读取命令行命令，知道用户想要做什么 |
| inquirer | 交互式命令工具，给用户提供一个提问流方式。（有一个类似的enquirer也是如此） |
| chalk  |  颜色插件，用来修改命令行输出样式，通过颜色区分info、error日志，清晰直观  |
| ora | 用于显示加载中的效果，类似于前端页面的loading效果，想下载模版这种耗时的操作，有了loading效果，可以提示用户正在进行中，请耐心等待  |
| globby | 用于检索文件  |
| fs-extra | node fs文件系统模块的增强版  |
| pacote | 获取node包最新版本等信息  |
| handlebars | 提供了必要的功能，使你可以高效地构建语义化模板 |
| download-git-repo | 通过node下载github，gitlab上面的项目，选择direct方式，直接url：direct:url#my-branch |

### 实现记录如下

#### 第一步
![选择当前需要的脚手架](/images/cli1.png)

#### 第二步
![从git上远程下载的脚手架集成内容](/images/cli2.png)



#### 第三步

![最后使用合适的包管理器进行安装](/images/cli3.png)


也可以使用下面的自定义指令进行脚手架的开发

## 001使用pnpm,vuecli创建项目的命令集合
### webpack框架创建使用npm init vue@3和npm create区别

~~~


默认都是依赖vite框架搭建。
npm init vue@2只能搭建vue2的vite框架。
npm init vue@3只能搭建vue3的vite框架。
npm  create可以搭建多种语言的vite框架。
（webpack对应关系，vuecli3对应的创建webpack4,vuecli5u对应webpack5）


~~~

### 搭建webpack的vue框架命令
vue init webpack mytestwebpack
遗憾的是：只能创建webpack的3.x版本，所以自己集成一个webpack4.x版本

~~~

vue createxxx或是vue init webpack xxx
之前vue-cli的命令行升级了，目前使用vue create可以创建vue2或是vue3
npm i -g @vue/cli-init安装全局，
然后创建项目
vue  create xxx
(vue-cli3集成了webpack4)
- vue2
npm install -g vue-cli;//验证vue -V
注意：vue2和vue3cli不能同时使用。
- vue3
npm install @vue/cli -g;//验证vue -V
(yarn安装 yarn global add @vue/cli)
vue create cli-vue2  // 创建cli-vue2项目  ，注意项目名称不能为驼峰
！！！！！！注意
vue init webpack mydemo 已经不能创建零零，需要升级一下
目前vue3中@vue/cli已经被移除了，使用npm i -g @vue/cli-init
然后vue init webpack mytestwebpack

~~~

#### 补充关于webpack创建项目脚手架5的功能命令

（1）在线一个npm包可以很快的创建纯webpack4cli项目：纯webapck内容，无其他配置

```
步骤1,2
npm init -f
npm i -D webpack-cli @webpack-cli/generators
然后就可以了：创建出来的webpackcli4.0版本
```

（2）在线创建webpack5的纯前端项目：包含css依赖，ts环境自动配置，css-loader加载，包下载器的选择

~~~
npm i webpack-cli @webpack-cli/init
npx webpack-cli init

~~~



### pnpm搭建项目命令+vite

~~~
pnpm create vite
注意这里如果搭建vue项目都是使用vue3,如何使用vue2+vite
~~~
#### pnpm搭建vue2+vite
~~~

安装一个vite脚手架，选择vanl

~~~
##### 第一步引入vue依赖

~~~
注意vue2.7.6和vue-template-compiler一一对应版本。
pnpm i vue@2.7.6 vite-plugin-vue2 element-ui vue-template-compiler sass

之后调整main.js
import Vue from "vue";
import App from "./App.vue";
import ElementUI from "element-ui";
import "element-ui/lib/theme-chalk/index.css";

Vue.config.productionTip = false;
Vue.use(ElementUI);

Vue.prototype.$bus = new Vue({
  render: (h) => h(App),
}).$mount("#app");



~~~

##### 第二步修改相关vite.config.js内容

~~~

pnpm i rollup-plugin-require-context generate-source-map
（对于require-context做兼容处理）
vscode中存储：viteconfigvue2xxx

~~~


注意：有时候el-table跑步起来，试试：好像是vue2.7版本的问题！ 换成2.6x 就好了。
当然暂时记录一下，有时候可以不报错。




## 002使用pnpm管理项目包的命令

### 设置包的安装位置
~~~

 -w 表示把包安装在 root 下，该包会放置在 <root>/node_modules 下。
 当然也可以把把安装在所有 packages 中，使用 -r 代替 -w。你必须使用其中一个参数。
 例如把 dayjs 装入 packages/web 下，packages/web 中的 package.json name 为 @test/web。
 需要执行：pnpm i dayjs -r --filter @test/web

~~~
### 全局安装和局部安装包的案例
~~~

把包安装到所有的项目
pnpm i dayjs -r 

把包安装在web-vite-client项目(项目名称package的name字段)
pnpm i color -r --filter web-vite-client


我们开发好@nyh/apis包之后安装到web-vite-client中

pnpm i @nyh/apis -r --filter web-vite-client

pnpm i axios -r --filter @test/utils
pnpm i json-bigint -r --filter @test/utils


~~~

## 003vite中全局变量的使用process

~~~
### 007vite中使用process.env
​~~~
import.meta.env打印
BASE_URL: "/"
DEV: true
MODE: "development"
PROD: false
SSR: false
MODE区分出来当前的命令


---vite中非要用process
使用 vite 安装 vue3 时，如果使用了 process.env，会遇到 process 未定义的情况，原因是 process.env 已经被移除了。解决办法是在 vite.config.ts 中增加 define：
和server同级配置
define: {
        'process.env': {}
}


​~~~
~~~





## 003补充对于vue2历史项目中一般是使用webpack，如何修改老项目成为vite脚手架基座。

之前腾讯出了一款wp2vite，这个插件可以转webpack配置到vite,但是需要配置的内容挺多。

好消息，有厉害的网友结合wp2vite出了一款，一键转webpack插件，可以尝试一下webpack-vite-serve

[webpack-vite-serve - npm (npmjs.com)](https://www.npmjs.com/package/webpack-vite-serve)

[webpack项目接入Vite通用方案介绍(下) (qq.com)](https://mp.weixin.qq.com/s/3VyfmV135Hi3Fvtal2oI0A)





#### 增加对于webpack插件和vite插件的配置比较

## 个人webpack转vite框架有一些简单的心得，仅仅用于简单配置的快速转换，见processOn

[001---前端工程化系统梳理 ProcessOn Mind](https://www.processon.com/mindmap/617781871efad44894fbe29d)



## 004webpack中开发一个plugin

webpack插件中，两个对象compiler编译对象是webpack启动后，一次性生成webpack环境配置，可以访问整个webpack的运行时期。插件应用时候，会收到整个对象的引用，可以访问webpack的主环境。

另一个compilation对象是webpack的实时生成的编译对象，一个compilation表现了当前的模块资源，编译内容依赖变化。

### 插件的时候原理

webpack打包是一种事件流的机制，它的原理是将各个插件串联起来。那么实现这一切的核心就是在compiler对象中的tapable，将plugin控制在webpack事件流上运行。（基本使用几个tap类中钩子：compile是创建compilation之前，compilation创建完成，emit输出资源到目录前，done编译完成）

注意webpack插件中旧的api:compiler.plugin，新的api是compiler.hooks.emit.tap("WebapckTransformplugins")

插件通过具有apply方法的prototype对象实例化出来。

### 插件的基本内容组成

~~~
从官网得知：编写一个webpack插件需要由以下组成：

1. 一个javascript命名函数。
2. 在插件函数的prototype上定义一个 apply 方法。
3. 指定一个绑定到webpack自身的钩子函数。
4. 处理webpack内部实列的特定数据。
5. 功能完成后调用webpack提供的回调函数。
~~~

### vue.config.js中内容

#### 开发插件的步骤：[项目地址](https://gitee.com/nyhxiaoning/vue3.0-ts-admin.git)



~~~

第一步：创建一个js命令的类，添加apply方法。
第二部：为这个类中增加不同webpack阶段的的狗子函数，处理专门的内容
第三步：callback调用防止卡到构建

注释，这里有一个注释：vue.config.js因为对于webpack进行了抽象，因此使用的插件方法如下
  chainWebpack: config => {
    // config.plugin('codecomment').use(
    //   new FileListPlugin({
    //     outputFile: 'my-assets.md'
    //   })
    // );
    config.plugin('loger').use(
      new LogWebpackPlugin(
        () => {
          debugger;
          console.log('emit已经派发了');
        },
        () => {
          console.log('done事件发生了，成功构建了');
        }
      )
    );
    
项目地址查看：

~~~



## webpack包管理工具的开发和使用记录

test-branch-ts分支：https://gitee.com/nyhxiaoning/vue3.0-ts-admin.git

### （1）开发webpack插件：快速去除log,error,table,info的插件。

利用apply注入一个函数对compilation进行操作。

webpack4和webpack5做一下兼容，判断compilation.hook上，如果是4属性为optimazeAsset如果是5，属性是processAsset



### （2）webpack插件函数封装：脚手架创建工具包cli

本质上：使用了commander命令行执行工具和inqur交互式解析器



### （3）webpack获取url在线地址url的相关信息内容：通过http模块。

因为每一个在线github包地址类似，

```Ruby
主分支是main或是master即可。
https://github.com/apache/echarts/blob/main/package.json
https://github.com/apache/echarts/blob/master/package.json
```

http.get（url）获取在线包



### （4）webpack获取每一个包的相关的最新版本和许可证信息实现思路

![当前的配置vue.config后功能输出](/images/webpackloader2.png)

```CSS
第一步：读取项目所有的依赖包。通过fs，然后将所有package.json内容返回。

返回后，获取到fs.read读取package.json后获取devDepences和depencies两个属性的所有内容。

取出当前的所有包。

第二步：将当前的所有包传入函数中，获取当前的每一个包对应的远程资源地址在线包git地址
可以通过http.get，http模块获取。

第二步：通过cheerio和request两个包，获取每一个包的html信息页面。
通过第一个的包名称和npm在线地址拼接获取到包url的在线地址，然后通过cheerio获取html页面信息。

第三步：获取到当前的html页面信息后，通过转成字符串获取当前的license的位置，截断获取当前的字符串，

这里注意去掉单引号和双引号的内容，转成对象最后，获取到的想要的信息

第四步：通过for循环，将所有的包对象放入一个大数组中，最后获取当前的所有的依赖的
许可证版本和最新版本
```





## 005vite中开发一个plugin



## 006monorepo项目介绍好处
Monorep 是把所有相关的 package 都放在一个仓库里进行管理，每个 package 独立发布。例如：React, Angular, Babel, Jest, Umijs, Vue

- 利用pnpm创建monorepo创建。
- Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。
但是yarn和lerna配置多，使用lerna需要增加package中一些lerna配置，同时维护一个leran.json，pnpm只需要简单的房一个yml的管理文件，其他全部不变。

pnpm 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录，而通过硬链为你节省了磁盘空间并提升安装速度。


用于多种技术栈跨平台的多个项目，相同依赖相同过多。
~~~
1、多个项目统一规范，因为用到是同一个封装
2、不需要每个项目复制一遍，因为用到是同一个封装
3、request变动的时候，只需要改一处即可，因为用到是同一个封装
4、后续有新子项目时，可以使用现成的封装库
当前目录设置
├── README.md
├── package.json
├── apis---存放api接口
├── utils---存放公共库函数
├── components---存放各种组件库
├── packages
│   ├── web-viteclient---web端项目
│   └── h5-vite-client
│   └── admin-vite
└── pnpm-workspace.yaml---创建当前的项目和文件


~~~

###  使用npm init vue@3和npm create vite区别
默认都是依赖vite框架搭建。
npm init vue@2只能搭建vue2的vite框架。
npm init vue@3只能搭建vue3的vite框架。
npm  create可以搭建多种语言的vite框架。

###  搭建webpack的vue框架命令
之前vue-cli的命令行升级了，目前使用vue create可以创建vue2或是vue3
npm i -g @vue/cli-init安装全局，或是npm install @vue/cli -g
然后创建项目
vue  create xxx
(vue-cli3集成了webpack4)

-如果使用webpack5,可以尝试下面的内容，没有试过
~~~
npm install -g @vue/cli@next# 
OR
yarn global add @vue/cli@next
升级所有插件 Upgrade All Plugins at Once
vue upgrade --next

~~~



~~~

- vue2
npm install -g vue-cli;//验证vue -V
注意：vue2和vue3cli不能同时使用。



- vue3
npm install @vue/cli -g;//验证vue -V
(yarn安装 yarn global add @vue/cli)
vue create cli-vue2  // 创建cli-vue2项目  ，注意项目名称不能为驼峰
~~~

目前vue3中@vue/cli已经被移除了，使用npm i -g @vue/cli-init

然后vue init webpack mytestwebpack

###  创建步骤monrepo项目方式

####  新建根目录
首先Monorepo需要一个根项目，所以我们先创建一个根项目，他相当于一个容器，用来存放我们的子项目，所以这个根项目并不需要安装太多的依赖
~~~

脚手架自己选pnpm create vite
vanilla---vite纯脚手架
vue
React
lit---lit+vite脚手架
Preact


~~~

####  创建 pnpm-workspace.yaml
新建pnpm-workspace.yaml文件，他的作用是：指定工作空间workspace的目录，里面的内容为：
~~~
packages:
  # 子项目存放的地方
  - 'packages/*'
  如果没有下面的可以放入一个包，其实怎么放都可以
  # 公用组件目录
  - 'components/**'
  # request目录
  - 'apis/**'
  # utils目录
  - 'utils/**'


~~~

####  创建公用目录（建议是一个只含有脚手架的容器）
~~~
npm create vite

Project name: apis
Select a framework: › vanilla
Select a variant: › vanilla-ts

npm create vite

Project name: utils
Select a framework: › vanilla
Select a variant: › vanilla-ts

npm init vue@3

Project Name -> compnents
Typescript -> Yes
JSX -> Yes
Pinia -> Yes
Testing -> No
Eslint -> Yes


~~~

####  子项目如何使用库：例如请求api库
https://mp.weixin.qq.com/s/y0cHuMxc7bC9Lhh5q2j5zQ

~~~
cd apis

npm i axios

创建和导出自己的apo封装代码后，
一般是接口请求拦截器和响应拦截器
然后src文件下，放一些模块的请求函数
在apis/src下创建：

request.ts---请求和响应拦截器
user.ts---api的封装接口

~~~

完成后，对于这个apis的包进行个性命令，因为这里的名称和版本号，决定了子项目引用时候这里的显示。
- 修改name和version（在package.json）

创建好之后，然后
####  项目引用这个包的时候
~~~
首先进入某一个项:这里的package.json中的name就是这里的api-nyh名称
pnpm  install  apis-nyh -D
默认安装到生产环境。


~~~

- 项目测试使用api---注意这里有个使用方法
首先引入包后，在包前面加上一个@test命名空间，这样即使包都是一类，但是命名空间不一样也可以，就可以随意的使用了，比如原来的包名称是api-ts
使用的时候必须加上@/apis-ts
这样，所有的包都可以一目了然的使用了，只要将整个项目用@xxxx引入以后，都是模块化的使用方式了
~~~

import { getUser，createUser } from '@api-ts'

注意打包后，其实是一个对象输出，
例如：多个导入一个对象（多个export仅仅适用于单个项目中，如果这个项目做lib库，那么只能导出一个对象，对象上挂属性或是方法）
//!!!注意这里的坑，被坑了
 export const userApi = {
    addFn: () => {
        return add
    },
    getUserFn: () => {
        return getUser
    },
    createUserFn: () => {
        return createUser
    },
    getCommentScheduleWeekFn: () => {
        return getCommentScheduleWeek
    },
    getCommentScheduleDayFn: () => {
        return getCommentScheduleDay
    },
    getSingleMusicDetailsFn: () => {
        return getSingleMusicDetails
    },
};



~~~



####   加快执行构建速度的vue3框架命令--skipLibCheck
~~~
一般项目vue3安装后，有一个脚本build，如下，但是有时候执行检查总是报错，那么可以跳过
pnpm i @test/utils -r --filter web-vite-client
"build": "vue-tsc --noEmit --skipLibCheck && vite build"


scripts.build 字段，原来里面执行了两条命令 vue-tsc --noEmit && vite build ，嗯？这个 vue-tsc 是干嘛的，查找了一下原来是对 vue 3 的一个类型检测工具，然后我尝试单独执行 vue-tsc --noEmit ，上面的报错出现了，原来是 vue-tsc 引起的错误。



~~~


####  包安装操作
~~~
 把包安装在哪里
 -w 表示把包安装在 root 下，该包会放置在 <root>/node_modules 下。
 当然也可以把把安装在所有 packages 中，使用 -r 代替 -w。你必须使用其中一个参数。
 例如把 dayjs 装入 packages/web 下，packages/web 中的 package.json name 为 @test/web。
 需要执行：pnpm i dayjs -r --filter @test/web

命令如下
把包安装到所有的项目
pnpm i dayjs -r 

把包安装在web-vite-client项目(项目名称package的name字段)
pnpm i color -r --filter web-vite-client



我们开发好apis包之后安装到web-vite-client中

pnpm i @nyh/apis -r --filter web-vite-client

pnpm i axios -r --filter @test/utils
pnpm i json-bigint -r --filter @test/utils
pnpm i @test/utils -r --filter web-vite-client


更新

pnpm up apis-ts -r --filter vue3-components
~~~

### pnpm项目配置需要增加配置全局ts.config.json:注意第一点

~~~
全局的tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable", "webworker"],
    "moduleResolution": "Node",
    "esModuleInterop": true,---------允许当前的es模块
    "strict": true,
    "allowJs": true,
    "declaration": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "noEmitOnError": true,
    "noUnusedLocals": false,
    "noImplicitAny": false,
    "declarationMap": true,-------------为源文件创建一个d.ts生命
    "isolatedModules": true
  },
  "references": [------------------这部分放一些相关的package包的引用，这里做关系的连接，如果包之间有引用关系
    { "path": "packages/apis-ts" },
    { "path": "packages/vue3-components" },
    { "path": "web-vue3-vite-meituan-ts" }
  ]
}

~~~

### 注意第二点：作为utils请求库，如果进行打包，配置tsconfig和package

~~~
tsconfig.json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,------这个属性
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["./src"]
}

package.json中配置：最后打包的类型（同时得益于全局tsconfig配置，declarationMap会生成.d.ts，自己不用创建了d.ts了）
{
    "name": "foo",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/foo.js",
    "typings": "./lib/foo.d.ts"
}
这里typeing是读取类型文件的路径，这个作为模块或是对外包的时候使用。
访问的时候尝试加载代码包路径下dist下的index.d.ts文件，这个文件也包含了文件类型信息。


~~~





## 007脚手架工具开发计划：vite开发一个库

### vite打包一个第三方lib

~~~
- [ ] ─ 15工具和项目配置工程化问题记录
- [ ] ─ 16前端拓展知识学习
- [ ] ─ 17低代码学习和总结 配置vite脚手架的库模式
 build: {
    lib: {
      // 测试库模式
      entry: path.resolve(__dirname, './src/lib/js/plain-draggable.esm.js'),
      name: 'myLib',
      // 生成的库的名称lib
      fileName: 'my-lib'
    },
    rollupOptions: {
      // TODO:设置一些不想要打包进行的依赖
      external: ['vue', 'axios', 'lodsh'],
      output: {
        // 在umd的模式下，为外部的依赖提供一个全局变量使用
        globals: {
          vue: 'Vue',
          axios: 'Axios',
          lodsh: 'Lodsh'
        }
      }
    }
  },
  
~~~



## 一个yarn安装项目的有趣后门
yarn安装包的时候，如果没有当前的package.json中的包，会让你选择当前的安装版本。
这样我们构建vite的项目或是其他项目可以使用yarn这个特性，选择版本脚手架。

比如讲package.json中的包后面多街上一个‘， "typescript": "^4.6.4'",
~~~
比如
  "devDependencies": {
    "@vitejs/plugin-vue": "^3.0.0",
    "typescript": "^4.6.4'",
    "vite": "^2.0.0'",
    "vue-tsc": "^0.38.4"
  }
  下面看到vite和ts都是后门版本多了一个'，这样显然没有这种版本，yarn就会列表出来。


~~~


## 一键给vite项目增加eslint和prerttier
~~~
已经创建好的vite框架中，使用node16.5.0，创建vite项目后，然后在项目中，使用
npm init vite-pretty-lint  
选择：vue-ts  yarn安装都可以实现。


~~~


## 三种 hash 区别（webpack文件指纹策略）

使用hash对于dev开发环境的js进行打包设置，

使用chunkhash对于不同的入口lib的依赖库进行打包构建

使用contenthash对于css文件进行打包设置。


hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值。(粒度整个项目)(一个文件改变，整个项目重新构建，因为共用一个hash)

chunkhash 是根据不同的入口进行依赖文件解析，构建对应的 chunk(模块)，生成对应的 hash 值。只有被修改的 chunk(模块)在重新构建之后才会生成新的 hash 值，不会影响其它的 chunk。(粒度 entry 的每个入口文件)(根据入口文件模块生成)

contenthash 是跟每个生成的文件有关，每个文件都有一个唯一的 hash 值。当要构建的文件内容发生改变时，就会生成新的 hash 值，且该文件的改变并不会影响和它同一个模块下的其它文件。(粒度每个文件的内容)

## 安装webpack的脚手架热更新修改后，没有自动刷新页面
如果是webpack4版本和vuecli4，那么看看配置hot:true属性打开了，。

如果是纯webpack3版本，那么需要安装webpack-dev-serve版本，同时增加到脚本中。



## vite脚手架有时候修改本地代码调试，无法同步更新浏览器展示
### 不要犯文件导入不一致命名的问题

### 配置vite的脚手架属性hmr：true


### 如果配置后，发现还是刷新后，代码没有同步，命令行原因（可能）
由于WSL2的限制，vite默认配置是无法监控windows文件系统中文件的变化的。
所以方法1：换一个命令行工具，比如powershell换成gitbash
方法2：配置vite内容
~~~
 server: {
    watch: {
      { usePolling: true }
    }
  }

~~~


## webpack没有热更新
### 在webpack4版本中，增加webpack-dev-server安装包，然后，在脚本启动的时候增加webpack-dev-server，同时配置devServer的hot:true

热更新是页面刷新reload的情况
解决办法：（ 怀疑和node版本有关系）
~~~

dev模式下，不能用merge。('webpack-merge')
dev模式下，不能用 MiniCssExtractPlugin.loader

~~~

"dev":中增加"webpack-dev-server --hot --open --progress",
--hot 不能少，或者devServer里配置 hot: true

### 如果有时候父子组件，子组件改完后，没有动静。
那么根据渲染机制，给父组件写一个js文件修改，启动更新生命周期。

### webpack5热更新失效，那么配置target
~~~
// 在entry和output的同级处，加上  target: 'web'
module.exports = {
    target: 'web',
    entry,
    output: {
        path: path.resolve(__dirname, 'dist')
    },
  ...
}


~~~

### 脚手架格式化实现解决方案

[000---前端架构师管理体系化管理学习-前端代码格式化配置](https://app.yinxiang.com/shard/s37/nl/24388549/717c6df8-60ec-4a80-b02e-c968f44016df)



## 008koa脚手架选择工具

实现思路：和上面的一样

[koa-ts-cli](https://github.com/nyhxiaoning/koa-ts-cli.git)

~~~
 koa-ts-base-template---基础koa-ts封装的脚手架工具，2.8.1，包含了router,view各种内容,模板是pug
  koa-ts-full-template
  koa-ts-full-stack-template
~~~







## 关于代码库是否可以使用git进行文件授权管理

如果要的就是集中式的管理模式，那用Git干嘛呢？使用svn.

从技术上将，Git可能永远也做不到类似SVN的路径授权（读授权）

- Git服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。
- 公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。

### 有人可能想到利用git的下载单个文件夹命令

但是这个对于程序员来说是骗人的，可以自己进入git的info文件夹下的sparse-checkout 文件夹，指定下载哪些文件夹。

~~~
- 具体使用在当前的命令行下创建一个文件夹
- 进入文件夹后git init
- 然后进入git的info文件夹创建一个sparse-checkout文件，添加想要下载的文件夹
注意：根目录使用/,比如下载根目录下的src:/src/*
- 配置git支持modules下载
git config core.sparseCheckout true

- 在当前的文件夹下下载项目

~~~

