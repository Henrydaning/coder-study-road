### NuxtAPI


### 资料和资源参考相关
[中文 NuxtAPI](https://www.nuxtjs.org.cn/getting-started/installation.html#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE)

- 印象笔记的文章：项目驱动一个Nuxt从0-1开始
入门：历时两个月！Nuxt3从入门到实战！你值得收藏！


### Nuxt3 版本的 Node 最低支持是 Node14

### nuxt 框架的搭建、配置记录

https://juejin.cn/post/7106397233905401864

### 1.Nuxt3 已经可以参考的 demo 地址

### 2.nuxt 打包部署 pm2

https://blog.csdn.net/m0_48489737/article/details/127796979

### 3.nuxt3 中新增 elementplus 插件教程。

[nuxt3-elementplus 实际 gitee 项目代码内容](https://gitee.com/node-project-summary/nuxt3-elementplus-vue3-demo.git)

[nuxt3 按需引入 elmentplus 内容](https://app.yinxiang.com/shard/s37/nl/24388549/1debe0f4-1fd7-4947-899e-b74867282a54)

### 4.nuxt3 中配置增加路由，自动新建一个 pages 中，文件夹就是路由名称。

### 5.自动导入 elementplus 组件

非常简单的实现。两步法

```
第一步：plugins增加内容
plugins中增加一个当前的样式文件：element-plus.ts
import * as ElementPlus from 'element-plus/dist/index.full'
import zhCn from 'element-plus/es/locale/lang/zh-cn'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(ElementPlus, {
    locale: zhCn,
  })
})


第二步：nuxt.config.ts配置样式
  css: [
    'element-plus/dist/index.css'
  ],
```

[指导自动导入 elementplus](https://juejin.cn/post/7108916330153115655)

### 6.nuxt 从 0-1 开发记录

[nuxt 记录从 0-1](https://juejin.cn/post/6844903833840123912#heading-34)

# Nuxt3 指导 API 网站学习

### 1.nuxt 自带相关 autoImport 的 API

```
Nuxt 自动导入辅助函数、可组合函数和 Vue API.
imports: {
    autoImport: false
  }

当然可以显式导入，
Nuxt使用别名公开每个自动导入，如果需要，别名可用于显式导入：#imports
  import { ref, computed } from '#imports'

```

### 2.渲染模式

```
redirect- 定义服务器端重定向。
ssr- 禁用应用各部分的服务器端呈现，并使其仅使用 SPAssr: false
cors- 自动添加 cors 标头 - 您可以通过覆盖来自定义输出cors: trueheaders
headers- 将特定标题添加到网站的各个部分 - 例如，您的资产
static和 - 启用单个（按需）构建; 启用静态构建，该构建持续可配置的 TTL。（目前在Netlify上支持完全增量静态生成，Vercel即将推出）swrstaticswr

export default defineNuxtConfig({
  routeRules: {
    // Static page generated on-demand, revalidates in background
    '/blog/**': { swr: true },
    // Static page generated on-demand once
    '/articles/**': { static: true },
    // Set custom headers matching paths
    '/_nuxt/**': { headers: { 'cache-control': 's-maxage=0' } },
    // Render these routes with SPA
    '/admin/**': { ssr: false },
    // Add cors headers
    '/api/v1/**': { cors: true },
    // Add redirect headers
    '/old-page': { redirect: '/new-page' },
    '/old-page2': { redirect: { to: '/new-page', statusCode: 302 } }
  }
})



```

### 3.public 文件夹

包含静态文件的目录，可通过 Nuxt 服务器直接访问，并在生成应用程序时自动复制到 dist 文件夹中。

### 4.pages 存放当前的路由自动生成

### 5.运行时配置允许向 Nuxt 应用上下文传递动态配置和环境变量。

它将在服务器端覆盖 publicRuntimeConfig 内相同内容。它应该用来保存私有环境变量(不应该在前端公开)。这可能包括对您的 API 秘密标记的引用。
配置传入全局变量

```
export default {
  privateRuntimeConfig: {
    apiSecret: process.env.API_SECRET,
  },
}

```

publicRuntimeConfig 配置相关的全局变量。

### 6.nuxt 配置 vite 配置和 webpack

#### vite

```
vite
将直接传递给 Vite 的配置。



```

#### webpack

```
webpack
watchOptions 直接传递给 webpack。

```

# 2.目录结构

### （1）组件命名：如下嵌套组件

```
| components/
--| base/
----| foo/
------| Button.vue
实际使用：<BaseFooButton />


```

### （2）库模式使用

制作具有自动摇树优化和组件注册功能的 Vue 组件库非常简单 ✨

你可以使用 components:dirs 钩子，轻松扩展目录列表，而无需用户在 Nuxt 模块中进行配置。

```
比如：awesome-ui的ui
| node_modules/
---| awesome-ui/
------| components/
---------| Alert.vue
---------| Button.vue
------| nuxt.js
| pages/
---| index.vue
| nuxt.config.js


```

第二步

```
import { join } from 'pathe'
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  hooks: {
    'components:dirs'(dirs) {
      // Add ./components dir to the list
      dirs.push({
        path: join(__dirname, 'components'),
        prefix: 'awesome',
      })
    },
  },
})


```

第三步：nuxt.config.js 使用

```
export default {
  buildModules: ['awesome-ui/nuxt'],
}

```

第四步： pages/index.vue 中，使用模块组件 (带 awesome- 前缀):

```
    <awesome-alert>Here's an alert!</awesome-alert>
它仅在使用时自动导入组件，并且在更新你在 node_modules/awesome-ui/components/ 的组件时支持热更新。

```

### 3.可复用组合逻辑 composables

用户在 composables 目录下创建的组合逻辑文件将会被系统自动识别导入到应用程序，以供全局使用。

#### （1）创建 useFoo.ts

在 composables 文件夹下新建 useFoo.ts 文件,编写组合逻辑代码。

#### (2)填充文件内容：useFoo.ts 中

```
import { useState } from '#app'

export const useFoo = () => {
  return useState('foo', () => 'bar')
}


```

#### （3）注意 nuxt3 中自动使用

编写好组合逻辑文件后，Nuxt3 就会自动的导入，您可以在应用程序中使用它而无需手动导入。
const foo = useFoo()

### 4.layouts 自定义布局

页面布局放置在 目录中，使用时会通过异步导入自动加载。
如果你创建了一个 这将用于你应用中的所有页面。
通过将 属性设置为组件选项的一部分来使用其他布局。

### 5.app.vue 入口文件+NuxtPage 配置

app.vue 文件是 Nuxt 3 应用程序中的入口组件。

在 Nuxt 3 中如果没有 pages/目录，则表示不会包含 vue-router 依赖。
当我们完成一个落地页或者是不需要路由就可以这样做。



### 6.useState内容API
Nuxt 提供可组合的 useState 来创建跨组件的并且对 SSR 友好的响应式状态。
useState 是一个 SSR 友好的 ref 替代品。它的值将会在服务端渲染（客户端渲染期间）后保留，并且使用唯一的键在所有组件之间共享。

通过配置：用自动导入 composables，我们可以定义全局的安全类型状态并且在整个应用中导入





### 7.nuxt渲染模式
目前前端渲染模式，大致分为 3 种：

（1）客户端渲染 CSR (Croswer Side Render)
（2）服务端渲染 SSR (Server Side Render)
（3）静态网站生成 SSG (Static Site Generation)

#### universal
Universal（SSR / SSG）
您选择后，就包含（内置）了服务端渲染（SSR）与静态网站生成（SSG）两种渲染模式。

服务端渲染是指客户端向服务器发出请求，然后运行时动态生成 html



### 8.nuxt.config.js配置
#### srcDir
定义 Nuxt 应用程序的源文件目录。

如果指定了相对路径，它将相对于 rootDir。
如果使用 ~ 别名，将从项目 srcDir 解析


#### ssr
默认使用ssr，表示true




### 9.nuxt缓存
nuxt的缓存可以分为组件级别缓存, API级别缓存以及页面级别缓存





#### 出口路由

如果需要使用 pages/显示相关页面的话，需要使用 

```

路由出口组件:<NuxtPage>
<template>
  <div>
    <!-- 路由出口 -->
    <NuxtPage />
  </div>
</template>

```

# 3.nuxt 安装完成后，不支持 require 方式（核心问题 vite 不支持 require）

解决安装 babel-node 版本，版本是 1.22.19

这个如果不能解决，其实问题是 vite 不支持 require 问题

vite-plugin-require-transform
