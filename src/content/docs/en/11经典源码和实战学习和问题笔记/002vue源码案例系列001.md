## Vue和react中的 minxin 混入的实现原理

### 方法1：不修改 Class，Vue 和 React 中 minxin 实现思路

```
class A {
    say() {
        console.log('A的函数say')
        return 1

    }
}
class B {
    test() {
        console.log('B的函数hi')
        return 122
    }
}
class C { }



function minxin(constructor) {
    return function (...args) {
        for (let arg of args) {
            // 获取当前的对象的所有的可枚举函数的属性遍历。
            for (let key of Object.getOwnPropertyNames(arg.prototype)) {
                if (key === 'constructor') continue;
                Object.defineProperty(constructor.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key))
            }
        }
    }
}
// 实现一个vue或是React的汇入minxin
// TODO:这里有一个问题：getOwnPropertyNames，列出对象多有的属性，可以枚举和不可以枚举的属性。
// TODO:getOwnPropertyDescriptor这个函数，返回当前对象的所有的属性描述。
// 代码一个对象有：基础属性，配置可以枚举是否，还有set和get方法

minxin(C)(A, B);

```



### 方法2：@Decorator函数使用的语法例子(注意ts中实验性特性)
<!-- 为了支持，这里使用相关的开启：experimentalDecorators全局打开，搜索 -->
~~~
class A {
    say() {
        console.log('A的函数say')
        return 1

    }
}
class B {
    test() {
        console.log('B的函数hi')
        return 122
    }
}
class C { }


// TODO:作为表达式调用时，无法解析类修饰器的签名。
// TODO:装饰器是一个ts的实验性的属性，所以这里的内容处理的方式
// tsconfig配置：compilerOptions里面使用：experimentalDecorators


@tag
class D{
    @method
    haaaa(){}
}

function tag(constructor:any) {
    console.log(constructor === A);
    console.log('判断是不是属于A')
}
/**
 * 判断当前的函数是不是构造函数属于A
 * @param target 
 */
function method(target:any) {
    console.log('判断使用了method装饰器')
    console.log(target.constructor === A, target === A.prototype)
}

let testc = new D();


~~~
