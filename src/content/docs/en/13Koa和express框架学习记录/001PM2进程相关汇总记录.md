### windows 进程相关，杀死进程命令

#### 1.查看当前的所有的进程和端口占用

```
查看端口占用 netstat -ano


```

#### 2.查看制定端口占用情况

```
netstat -aon|findstr 8080       数字为端口号


```

#### 3.杀掉进程：taskkill

```
taskkill /f /PID 22524    杀PID




```

### PM2 是什么
使用pm2来彻底掌握微服务运维精髓
[相关 PM2 的使用记录](https://app.yinxiang.com/shard/s37/nl/24388549/5d7140a1-b1ca-4cc5-9e81-c32a6d7ed19e)

PM2 是 node 进程管理工具，可以利用它来简化很多 node 应用管理的繁琐任务，这里推荐一个 node 版本控制工具--nvm。

### 1.为什么使用 pm2

线上项目，如果直接通过 node app 来启动，因为 node 是单线程的，所以如果报错了可能会使项目直接停止，从而导致整个服务崩溃。

#### 一般监控 node 有几种方案：

supervisor: 一般用作开发环境的使用；
forever: 管理多个站点，一般每个站点的访问量不大的情况，不需要监控；
PM2: 网站的访问量比较大，需要完整的监控页面。

### 2.pm2 的优点

pm2 优点

（1）后台运行(关掉 cmd 窗口依然运行)
（2）0 秒停机重载，维护升级时不需要停机
Linux (stable) & MacOSx (stable) & Windows (stable).多平台支持
（3）进程守护 (停止不稳定的进程，避免无限循环)
（4）内建负载均衡
（5）实时控制台检测
（6）提供 HTTP API 等
（7）远程控制和实时的接口 API ( nodejs 模块,允许和 PM2 进程管理器交互 )
（8）不仅仅可以启动 node 程序，对于一般的脚本程序同样可以自动化部署项目

### 3.pm2 配置文件启动

```
在上面的启动命令例子中，有一条pm2 start app.json命令，可以在app.json文件中添加配置
apps:json结构，apps是一个数组，数组中的每一个对象就对应一个pm2中运行的应用

参数控制：

name:应用程序名称
args:脚本的参数域
cwd:应用程序所在的目录
script:应用程序的脚本路径
log_date_format:
node_args:node 的参数域
error_file:自定义应用程序的错误日志文件
out_file:自定义应用程序日志文件
pid_file:自定义应用程序的pid文件
instances:
min_uptime:最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量
max_restarts:设置应用程序异常退出重启的次数，默认15次（从0开始计数）
cron_restart:定时启动，解决重启能解决的问题
watch:是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，  pm2会自动重载。这里也可以设置你要监控的文件。
merge_logs:
exec_interpreter:应用程序的脚本类型，这里使用的shell，默认是nodejs
exec_mode:应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork
autorestart:启用/禁用应用程序崩溃或退出时自动重启
vizion:启用/禁用vizion特性(版本控制)


{
  "apps": [
    {
      "name": "serverName", // 名称
      "script": "./index.js", // 入口文件
      "env": { // 环境
        "NODE_ENV": "development"
      },
      "env_production": {
        "NODE_ENV": "production"
      },
      "instances": 4, // 启用多少个实例
      "exec_mode": "cluster", // 应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork
      "max_restarts" : 3, // 设置应用程序异常退出重启的次数，默认15次（从0开始计数）
      "restart_delay" : 5000, // 异常重启情况下，延时重启时间
      "log_date_format" : "YYYY-MM-DD HH:mm Z",
      "combine_logs" : true,
      "log_file": "<yourpath>/combined.outerr.log", // 日志目录
      "out_file": "<yourpath>/out.log",
      "error_file": "<yourpath>/err.log",
    }
  ]
}


```

#### ecosystem.config.js 配置文件

```
module.exports = {
  // apps是一个json结构的数组 ，每一个数组成员对应一个pm2中运行的应用
  apps : [
    {
      // 应用程序名称
      name: 'next-test',
      // 执行文件
      script: 'index.js',
      // 应用程序所在的目录
      cwd: './',
      // 传递给脚本的参数
      args: '',
      // 指定的脚本解释器
      interpreter: '',
      // 传递给解释器的参数
      interpreter_args: '',
      // 是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。
      watch: true, // watch: './',
      // 不用监听的文件
      ignore_watch: [
        'node_modules',
        'logs'
      ],
      // 应用程序启动模式，这里设置的是 cluster_mode（集群），默认是fork
      exec_mode: 'cluster_mode',
      // 应用启动实例个数，仅在cluster模式有效 默认为fork；或者 max
      instances: 4,
      // 最大内存限制数，超出自动重启
      max_memory_restart: 8,
      // 自定义应用程序的错误日志文件(错误日志文件)
      error_file: './logs/app-err.log',
      // 自定义应用程序日志文件(正常日志文件)
      out_file: './logs/app-out.log',
      // 设置追加日志而不是新建日志
      merge_logs: true,
      // 指定日志文件的时间格式
      log_date_format: 'YYYY-MM-DD HH:mm:ss',
      // 最小运行时间，这里设置的是60s即如果应用程序在* 60s内退出，pm2会认为程序异常退出，此时触发重启* max_restarts设置数量，应用运行少于时间被认为是异常启动
      min_uptime: '60s',
      // 设置应用程序异常退出重启的次数，默认15次（从0开始计数）,最大异常重启次数，即小于min_uptime运行时间重启次数；
      max_restarts: 10,
      // 启用/禁用应用程序崩溃或退出时自动重启，默认为true, 发生异常的情况下自动重启
      autorestart: true,
      // 定时启动，解决重启能解决的问题，crontab时间格式重启应用，目前只支持cluster模式;
      cron_restart: '',
      // 异常重启情况下，延时重启时间
      restart_delay: '60s',
      // 环境配置
      // env: {
      //   // 公共变量
      //   COMMON_VARIABLE: true
      // },
      // 生产环境配置
      // $ pm2 start app.js --env
      env: {
        // 环境参数，当前指定为生产环境 process.env.NODE_ENV
        NODE_ENV: 'production',
        // 当前环境接口地址，如果不用可不配置 process.env.REMOTE_ADDR
        REMOTE_ADDR: 'http://www.dzm.com/'
      },
      // 开发环境配置
      // $ pm2 start app.js --env_dev
      env_dev: {
        // 环境参数，当前指定为开发环境 process.env.NODE_ENV
        NODE_ENV: 'development',
        // 当前环境接口地址，如果不用可不配置 process.env.REMOTE_ADDR
        REMOTE_ADDR: 'http://www.dzm-dev.com/'
      },
      // 测试环境配置
      // $ pm2 start app.js --env_test
      env_test: {
        // 环境参数，当前指定为测试环境 process.env.NODE_ENV
        NODE_ENV: 'test',
        // 当前环境接口地址，如果不用可不配置 process.env.REMOTE_ADDR
        REMOTE_ADDR: 'http://www.dzm-test.com/'
      }
    }
  ],

  // 环境部署
  deploy : {
    // 生成环境
    // 1、上传代码到云端仓库
    // 2、部署命令预览：
    // 首次部署: $ pm2 deploy ecosystem.json production setup
    // 更新版本: $ pm2 deploy ecosystem.json production update
    // 返回上一个版本: $ pm2 deploy ecosystem.json production revert 1
    // 3、执行首次部署：$ pm2 deploy ecosystem.json production setup
    // 4、执行部署运行：$ pm2 deploy ecosystem.json production
    // 5、看到 success 成功，报错看错误自行百度
    production : {
      // ssh的用户名，登录远程服务器的用户名
      user : 'dzm',
      // 要发布的机器，远程服务器的IP或hostname，此处可以是数组同步部署多个服务器，不过鉴于我们只有一个服务器，因此我们填写 10.0.90.164
      host : '10.0.90.164',
      // 服务器端口
      port : 8083,
      // 要发布的代码分支，远端名称及分支名
      ref  : 'origin/master',
      // 代码Git仓库地址
      repo : 'git@gitlab.dzm.net:dzm/nuxt-test',
      // 服务器存储代码地址，远程服务器部署目录，需要填写user具备写入权限的目录，也就是服务器存放上面git库代码的地方
      path : '/usr/local/var/www/production',
      // ssh权限配置
      // 'ssh_options': 'StrictHostKeyChecking=no',
      'ssh_options': ['StrictHostKeyChecking=no', 'PasswordAuthentication=no'],
      // 1、在 setup 前触发，如安装 git
      'pre-setup': '',
      // 2、在 setup 后触发，如做一些其他配置
      'post-setup': '',
      // 3、在 deploy 前触发，执行本地脚本
      'pre-deploy-local': '',
      // 4、在 deploy 前触发，执行远程脚本
      'pre-deploy': 'git fetch --all',
      // 5、在 deploy 后触发，执行远程脚本，如 npm install，部署后需要执行的命令
      // 'post-deploy' : 'npm install && pm2 startOrRestart ecosystem.config.js --env production',
      'post-deploy' : 'npm install && pm2 reload ecosystem.config.js --env production',
      // 环境变量
      'env'  : {
        // 指定为生成环境
        'NODE_ENV': 'production'
      }
    }
  }
};




```

#### ecosystem.config.js和pm.json区别

### 4.查看与监视进程

pm2 list：显示所有进程信息；
pm2 show 11，pm2 info 11：查看进程 id 为 11 的详细信息；
pm2 monit：进入监视页面，监视每个 node 进程的 CPU 和内存的使用情况。

### 5.重载、重启

pm2 restart 11：重启 id 为 11 的进程；
pm2 restart all：重启所有进程；
pm2 reload 11：0 秒停机重载 id 为 11 进程（用于 NETWORKED 进程）；
pm2 reload all：重载所有进程

pm2 stop all 关闭所有的进程

pm2 save 保存当前的pm进程
### 6.案例：使用 pm2 自动化部署 node 项目

#### 最小案例 1

```
1.全局安装：
npm install pm2 -g

2.启动js脚本：
pm2 start start.js
- 还可以指定程序名称
pm2 start start.js --name application1
- 选择集群启动模式
// -i 表示 number-instances 实例数量
// max 表示 PM2将自动检测可用CPU的数量 可以自己指定数量
pm2 start start.js -i max

```

#### 真实 node 案例

确保服务器安装 pm2

###### (1)项目根目录创建 deploy.yaml 文件

```
# deploy.yaml
apps:
  - script: ./start.js       # 入口文件
    name: 'app'              # 程序名称
    env:                     # 环境变量
      COMMON_VARIABLE: true
    env_production:
      NODE_ENV: production

deploy:                     # 部署脚本
  production:               # 生产环境
    user: lentoo            # 服务器的用户名
    host: 192.168.2.166     # 服务器的ip地址
    port: 22                # ssh端口
    ref: origin/master      # 要拉取的git分支
    ssh_options: StrictHostKeyChecking=no # SSH 公钥检查
    repo: https://github.com/**.git # 远程仓库地址
    path: /home              # 拉取到服务器某个目录下
    pre-deploy: git fetch --all # 部署前执行
    post-deploy: npm install &&  pm2 reload deploy.yaml --env production # 部署后执行
    env:
      NODE_ENV: production


```



### 7.案例7管理一个迷你的微服务平台
