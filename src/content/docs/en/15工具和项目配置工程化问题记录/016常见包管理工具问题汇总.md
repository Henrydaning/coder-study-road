## 一、包管理工具的一些经典问题：理解 npm,yarn,pnpm 的核心不同点

### 1.npm 和 yarn 扁平化解决了部分扁平化问题，但是也会 存在 A 下面嵌套

npm3.x 之前，不同的依赖树分支里，可能有大量实际上是同样版本的依赖。比如 A 包里面可能依赖了 C 包，D 包里面依赖了 C 包，E 包里面依赖了 C 包，导致这样大量的依赖冗余。
npm2 是以嵌套方式安装所有依赖项，但 npm3 试图减轻这种嵌套导致的深度和冗余。 npm3 通过把一些 secondary 依赖项和 primary 依赖项平铺在同一层级的方式来实现这一点。
主要的区别是：
● 目录结构中的位置不再代表着依赖项的类型（primary、secondary 等）
● node_modules 的目录结构取决于安装顺序

### 2.怎么理解 npm3.x 中 node_modules 目录结构取决于安装顺序

如果一个 secondary 的依赖同时被两个 primary 依赖所依赖，但是这个 secondary 依赖并没有被下载到顶层目录中，那么它将会被分别下载到这两个 primary 依赖的目录下，这就出现了重复！
但是如果说这个 secondary 的依赖已经被下载到顶层目录中，那它将会在这两个 primary 依赖中共享，并不会出现重复下载！

### 3.yarn 是怎么解决依赖重复很多次，嵌套路径过长的问题的呢？

铺平。所有的依赖不再一层层嵌套了，而是全部在同一层，这样也就没有依赖重复多次的问题了，也就没有路径过长的问题了。
但是一些包也会有一些 node_modules，因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。

### 4.相同的 yarn 和 npm 解决不了的问题：幽灵依赖

扁平化的方案也有相应的问题。
最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。
这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。
但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。
这就是幽灵依赖的问题。

### 5.pnpm 怎样解决幽灵依赖的问题

pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。
这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。
pnpm 就是凭借这个对 npm 和 yarn 降维打击的。

### 6.具体讲讲这个 pnpm 的 node_modules 解决幽灵依赖原理

pnpm 是如何解决这个嵌套依赖问题：两个诀窍
Pnpm 的新用户们经常会问我关于 pnpm 创建的奇怪的 node_modules 结构。 为什么不是平铺的？ 次级依赖去哪了？
第一个：node_modules 中只有一个叫 .pnpm 的文件夹以及一个叫做 express 的符号链接。但与 npm v3,4,5,6 或 yarn v1 创建的平铺的 node_modules 不同的是，它保留了包之间的相互隔离。
第二个：pnpm 的 node_modules 结构的第二个诀窍是包的依赖项与依赖包的实际位置位于同一目录级别。express 所有的依赖都软链至了 node_modules/.pnpm/ 中的对应目录。
补充一个点：
有 peer 依赖的包的结构更加复杂一些，但思路是一样的：使用软链与平铺目录来构建一个嵌套结构。

### 7.说说对于 pnpm 的软连接和硬链接

```
--------------软链接
node_modules 中只有一个叫 .pnpm 的文件夹以及一个叫做 express 的符号链接。
express 所有的依赖都软链至了 node_modules/.pnpm/ 中的对应目录。

--------------硬链接
pnpm 会在全局的 store 目录里存储项目 node_modules 文件的 hard links 。
在 pnpm 中，看上去这个 a 依赖同时占用了 1MB 的 node_modules 目录以及全局 store 目录 1MB
 的空间(加起来是 2MB)，
 但因为 hard link 的机制使得两个目录下相同的 1MB 空间能从两个不同位置进行寻址。

pnpm


```

## 二、ni 这个包工具解决很多的包管理器中的不兼容问题和切换问题

Mac 的上使用 ni 来管理在不同包管理器中的项目

### （1）ni 可以帮助你选择正确包版本的管理器工具。

Mac 下安装通过：ni 或是@antfu/ni 建议使用这个，Mac 和 Windows 一样

～～～
右侧：npm i @antfu/ni
安装后，相当于你可以用一个命令来自动安装所有环境包，不用担心有时候 npm 不能安装，换成 yarn 安装包，或是 pnpm 安装。、
～～～

### （2）详细命令使用汇总

～～～
初始化安装项目所有的依赖命令
ni 表示下面的内容
npm install
yarn install
pnpm install
bun install
—————安装 vite 包
ni vite 表示下面的内容
npm i vite
yarn add vite
pnpm add vite
bun add vite
—————安装一个包的案例，锁定版本
ni --frozen 表示下面的内容：
npm ci
yarn install --frozen-lockfile (Yarn 1)
yarn install --immutable (Yarn Berry)
pnpm install --frozen-lockfile
bun install --no-save

———-启动命令项目
nr dev --port=3000 表示下面的内容：
npm run dev -- --port=3000
yarn run dev --port=3000
pnpm run dev -- --port=3000
bun run dev --port=3000

————卸载命令
nun webpack 表示下面的内容：
npm uninstall webpack
yarn remove webpack
pnpm remove webpack
bun remove webpack
—————锁定版本，部署
nci 表示下面的内容：
npm ci
yarn install --frozen-lockfile
pnpm install --frozen-lockfile
bun install --no-save
～～～

### 3.ni 的原理

ni 包其实通过目录下的 lock 文件，如果当前文件夹没有，会递归查找。然后自动选择当前的包。

- 多个 lock 文件，根据优先级：pnpm>yarn>npm
- 什么 lock 都没有，询问使用哪一个包管理工具
- ni 帮我选择好包管理器，但是我没有装：会询问是否安装对应的包管理工具

### 4.老项目是否可以使用其他的包管理工具

有时候，老项目对于 yarn 和 pnpm 没有用过，这个也可以。
使用 yarn import 或是 pnpm import 后，会通过当前的 package-lock.json 生成 lock 包文件，避免冲突太多。

### 5.ni 使用的好处

目前前端有 npm、yarn、pnpm 等一些包管理器工具，在新、老项目中穿插使用不同包管理器工具会让我们具有蛮大的心智负担，稍有不慎可能还会犯错。

同时管理好了多个包下载的会出错的问题，自动帮忙使用包管理器下载。

## 三.corepack 工具

默认 node 的版本全局命令
Note\* 因为 Node.js Corepack 还没有稳定，处于实验状态，所以需要我们手动启用，Node.js 更新很快的，相信过不了多久，安装完 Node.js 默认就启用 Node.js Corepack 功能了。
-------------------------------Node14.18.2------------------------------------
v14.18.2 版本的 Node.js 只有三个全局命令，分别为 node、npm、npx。
-------------------------------Node16.15.1------------------------------------
v16.15.1 版本的 Node.js 有四个命令，分别为 corepack、node、npm、npx。

Node16 之后，有一个 corepack 工具，用于管理 yarn 和 pnpm.

### （1）开启 corepack 功能

使用前，确保全局没有安装 yarn 和 pnpm 全局命令。

corepack enable
(停用命令：corepack disable)
（corepack enable npm
corepack disable npm）

开启后，发现创建了四个全局命令在 bin 下面。

```
整个过程没有下载任何东西，corepack 只是简单的创建了四个快捷命令，
此时全局就可用 pnpm 和 yarn 命令了，默认安装的版本如下。



```

### （2）Node.js Corepack 的优缺点

- 优点
  可以配置只可以使用 pnpm 或是 yarn 下载，利用 package 字段中配置一个 "packageManager": "pnpm@7.3.0"字段，（这里表示只能配置使用 pnpm）。

- 缺点
  Node.js Corepack 默认无法拦截 npm



### （3）Corepack可以指定全局包管理器
corepack prepare pnpm@6.32.23 --activate

上面这个命令中：prepare表示下载，activate表示此版本设置为默认。我们可以指定当前的默认pnpm的版本。



### （4）生产环境需要离线的包的管理。
对于许多生产环境没有网络访问权限，我们可以先下载下来然后使用本地包管理工具。

比如新建一个项目：ntestproject，然后在当前的文件夹下面使用下面命令：
corepack  prepare  --all  -o=F:/corepack/cache.tgz
上面下载完成。
然后启用本地的包的命令，将之前下载的位置内容使用，如下命令：
corepack  hydrate  F:/corepack/cache.tgz 

(当然也有一步到位的命令：使用如下命令)
corepack  hydrate F:/corepack/cache.tgz  --activate


### （5）王者组合：ni和corepack
因为Corepack是包增强工具，好处不用下载yarn和pnpm，搭配packageManager还能避免包管理混用。
但是有时候只用一个包管理器不能保证你的包可以完全下载成功，所以我们辅助工具ni上面已经说过，可以帮忙我们自动配置修改一下工具。

(corepack prepare pnpm@6.32.23 --activate 用于管理当前的pnpm和yarn版本)


记得使用王者组合的三个命令组合：
~~~
1.corepack enable。
2.corepack enable npm。
3.安装 ni

~~~



## 四,横空出世的bun
https://juejin.cn/post/7120179470136246309#heading-8

[待整理](https://juejin.cn/post/7120179470136246309#heading-8)

Bun,JavaScript中的热点。
Bun不仅仅是一个Javascript运行时，它还包括电池。它配备了Javascript项目中通常需要的所有工具：一个包管理器、一个捆绑器和一个转译器，它不仅适用于Javascript，也适用于Typescript和JJS开箱即用。此外，它还包括一个用于dotenv配置加载的本地实现和一个SQLite3客户端
- 包管理工具
- 转译器
- 捆绑器
- TS开箱就用:直接使用ts
- dotenv加载本地实现
- SQLlite客户端

### Bun为什么这么快？
Bun优化到极致的决定是选择了Zig作为它的构建语言。Zig是一种没有垃圾收集器的低级编程语言，像C或Rust。虽然这两种语言可能是构建Bun的最佳选择。

### 安装Bun和执行ts和数据库
curl https://bun.sh/install | bash

~~~
尝试直接使用和执行ts代码：

export default {
    port:3400,
    fetch(request:Request):Response{
        let a:number = 56;
        let b:number = 45;
        console.log(a+b)
        return new Response(`hello world${a}${b}`)
    }
}



测试一下命令行：
curl http://localhost:3400

~~~

### 使用Bun启动sqlite带的数据库
Bun项目记录：[Bun项目BunInitProject](https://gitee.com/front-end-tool-development/bun-init-project.git)
