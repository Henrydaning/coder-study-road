![成长](/images/home.png)



### 回到博客主页

[前端工程化 vite 和 webpack,bael,eslint 汇总 processOn]([001---前端工程化系统梳理 ProcessOn Mind](https://www.processon.com/mindmap/617781871efad44894fbe29d))

```
核心部分
---一个比上面更全面的文章可以看看：webpack2 + vue2 老项目迁移 vite 成功
---webpack打包原理
---vite和webpack
---webpack中的hash三种模式

```

[博客首页](./../README.md)

### 000 脚手架工具的选型和使用

#### 脚手架的核心学习就亮点：bin 字段的使用理解和 download-git-repo 下载器的正常使用

脚手架地址：
[cli 脚手架参考地址](https://gitee.com/nyhxiaoning/cli-template.git)
注意：按照下面的开发计划不能展示：需要全局安装一个这个：npm-package-privatify,为了生成全局的可执行文件，添加到命令行下面执行命令。
否则 js 脚本项目无法通过命令行执行。
（）
[npm-package-privatify](一个将私有源npm包处理为离线包的自动化工具)

#### 目前自己有两个脚手架

- cli-create-template 准备修改优化一下这个包

- henry-cli-creator---这个可以使用

```
- henry-template-cli---这个需要自己npm run build后才能使用，废弃
```

### npm 开发一个标准化包
案例地址：[npmlib案例地址](https://gitee.com/front-end-tool-development/npmRollupLibStandrad.git)
#### 只说核心


### npm 版本控制
这个前提：在npm是当前的包地址，同时这个git提交需要提交完成，不能有暂存。
```
快捷版本
 npm  i release-it @release-it/conventional-changelog -D
 接着：npm init release-it
 最后必须执行两次npm run release-it
```

#### （1）项目安装 release-it
~~~
npm i release-it
配置 package 中script增加 release:
"release": "release-it"
~~~
#### （2）增加相关项目记录内容 log 记录

npm i @release-it/conventional-changelog
因为我们 npm run release 后，会有相关的日志记录

#### （3）为了更好的记录 diff，我们需要执行一下 npm init release-it

初始化整个项目，更好的形成记录
这里需要执行两次，必须执行两次：

```
第一次：npm init release-it后package选择后，会在package中增加一个字段  "release-it": {}
这块目的是：大版本小版本的控制位置，
第二次：npm init release-it后选择形成一个 .release-it.json配置文件，增加下面的配置内容钩子

{
    "github": {
        "release": true
    },
    "git": {
        "commitMessage": "release: v${version}"
    },
    "npm": {
        "publish": true
    },
    "hooks": {
        "after:bump": "echo 更新版本成功"
    },
    "plugins": {
        "@release-it/conventional-changelog": {
            "preset": "angular",
            "infile": "CHANGELOG.md"
        }
    },
}

```

案例地址：[husky+release-it案例地址](https://gitee.com/front-end-tool-development/npmRollupLibStandrad.git)
### 如何 npm 发布一个包

第一，npm login 的时候，nrm 切换到 npm 的镜像源地址。

注意登录前，注意自己的 nrm 镜像源位置，
如果是公司内部的镜像源，那么就连接那个，如果是公网，那么使用 npm 镜像。
否则 403

第二：出现下面校验，使用方法登录 npm 网站，点击 account
npm ERR! This operation requires a one-time password from your authenticator.

然后自己选择 npm 内部的双因子认证登录，避免丢失。
自己下载 authenticator 后，扫描即可。

最后，npm publish 后，发现错误说，你不能发布名为 lib 的包，意思是重名了。

#### You do not have permission to publish "henry-cli". Are you logged in as the correct user?

更换包名即可：package.json 的 name 名称修改

#### 尝试发布三个包：

第一个是：[cli 脚手架参考地址](https://gitee.com/nyhxiaoning/cli-template.git)

第二个是：

#### 脚手架二次封装原因

因为作为开发，已经从接触了 vue2,eslint,prettier,ts,webpack,vite,react 这些框架的太多大家已经有了最优实现，可以快速在项目中使用。

因此内置脚手架可以最大限度的实现提效。这样每一次的项目创建，可以最快的使用历史上的最优代码，而不是通过各种代码的删减，粘贴和测试，在初始化标准工程上再花费太多时间，使用业界的 ts+eslint+prettier+ts 作为校验工具，同时各种最优的实现库：比如 ts 封装的 axios 库，比如 vue3 的组件库框架，比如最新的 vue-request，vueUse，自动导入组件工具，monorepo 实现等等这些框架和技术都是前辈和自己历经 bug 的结果，所以沉淀下来，可以快速作为新的起点，而且这个起点经得住考验。

#### 脚手架基本使用了以下几个工具插件，功能说明了，利用这些组件进行交互

都说站在巨人的肩膀上，一个好的包能让你事半功倍，搭建一个基础的脚手架需要依赖以下包
| 包名 | 用途 |
| --- | --- |
| commander | 命令行工具，读取命令行命令，知道用户想要做什么 |
| inquirer | 交互式命令工具，给用户提供一个提问流方式。（有一个类似的 enquirer 也是如此） |
| chalk | 颜色插件，用来修改命令行输出样式，通过颜色区分 info、error 日志，清晰直观 |
| ora | 用于显示加载中的效果，类似于前端页面的 loading 效果，想下载模版这种耗时的操作，有了 loading 效果，可以提示用户正在进行中，请耐心等待 |
| globby | 用于检索文件 |
| fs-extra | node fs 文件系统模块的增强版 |
| pacote | 获取 node 包最新版本等信息 |
| handlebars | 提供了必要的功能，使你可以高效地构建语义化模板 |
| download-git-repo | 通过 node 下载 github，gitlab 上面的项目，选择 direct 方式，直接 url：direct:url#my-branch |

#### 实现记录如下

###### 第一步

![选择当前需要的脚手架](/images/cli1.png)

###### 第二步

![从git上远程下载的脚手架集成内容](/images/cli2.png)

###### 第三步

![最后使用合适的包管理器进行安装](/images/cli3.png)

也可以使用下面的自定义指令进行脚手架的开发

### 001 使用 pnpm,vuecli 创建项目的命令集合

#### webpack 框架创建使用 npm init vue@3 和 npm create 区别

```


默认都是依赖vite框架搭建。
npm init vue@2只能搭建vue2的vite框架。
npm init vue@3只能搭建vue3的vite框架。
npm  create可以搭建多种语言的vite框架。
（webpack对应关系，vuecli3对应的创建webpack4,vuecli5u对应webpack5）


```

#### 搭建 webpack 的 vue 框架命令

vue init webpack mytestwebpack
遗憾的是：只能创建 webpack 的 3.x 版本，所以自己集成一个 webpack4.x 版本

```

vue createxxx或是vue init webpack xxx
之前vue-cli的命令行升级了，目前使用vue create可以创建vue2或是vue3
npm i -g @vue/cli-init安装全局，
然后创建项目
vue  create xxx
(vue-cli3集成了webpack4)
- vue2
npm install -g vue-cli;//验证vue -V
注意：vue2和vue3cli不能同时使用。
- vue3
npm install @vue/cli -g;//验证vue -V
(yarn安装 yarn global add @vue/cli)
vue create cli-vue2  // 创建cli-vue2项目  ，注意项目名称不能为驼峰
！！！！！！注意
vue init webpack mydemo 已经不能创建零零，需要升级一下
目前vue3中@vue/cli已经被移除了，使用npm i -g @vue/cli-init
然后vue init webpack mytestwebpack

```

###### 补充关于 webpack 创建项目脚手架 5 的功能命令

（1）在线一个 npm 包可以很快的创建纯 webpack4cli 项目：纯 webapck 内容，无其他配置

```
步骤1,2
npm init -f
npm i -D webpack-cli @webpack-cli/generators
然后就可以了：创建出来的webpackcli4.0版本
```

（2）在线创建 webpack5 的纯前端项目：包含 css 依赖，ts 环境自动配置，css-loader 加载，包下载器的选择

```
npm i webpack-cli @webpack-cli/init
npx webpack-cli init

```

#### pnpm 搭建项目命令+vite

```
pnpm create vite
注意这里如果搭建vue项目都是使用vue3,如何使用vue2+vite
```

###### pnpm 搭建 vue2+vite

```

安装一个vite脚手架，选择vanl

```

####### 第一步引入 vue 依赖

```
注意vue2.7.6和vue-template-compiler一一对应版本。
pnpm i vue@2.7.6 vite-plugin-vue2 element-ui vue-template-compiler sass

之后调整main.js
import Vue from "vue";
import App from "./App.vue";
import ElementUI from "element-ui";
import "element-ui/lib/theme-chalk/index.css";

Vue.config.productionTip = false;
Vue.use(ElementUI);

Vue.prototype.$bus = new Vue({
  render: (h) => h(App),
}).$mount("#app");



```

####### 第二步修改相关 vite.config.js 内容

```

pnpm i rollup-plugin-require-context generate-source-map
（对于require-context做兼容处理）
vscode中存储：viteconfigvue2xxx

```

注意：有时候 el-table 跑步起来，试试：好像是 vue2.7 版本的问题！ 换成 2.6x 就好了。
当然暂时记录一下，有时候可以不报错。

### 002 使用 pnpm 管理项目包的命令

#### 设置包的安装位置

```

 -w 表示把包安装在 root 下，该包会放置在 <root>/node_modules 下。
 当然也可以把把安装在所有 packages 中，使用 -r 代替 -w。你必须使用其中一个参数。
 例如把 dayjs 装入 packages/web 下，packages/web 中的 package.json name 为 @test/web。
 需要执行：pnpm i dayjs -r --filter @test/web

```

#### 全局安装和局部安装包的案例

```

把包安装到所有的项目
pnpm i dayjs -r

把包安装在web-vite-client项目(项目名称package的name字段)
pnpm i color -r --filter web-vite-client


我们开发好@nyh/apis包之后安装到web-vite-client中

pnpm i @nyh/apis -r --filter web-vite-client

pnpm i axios -r --filter @test/utils
pnpm i json-bigint -r --filter @test/utils


```

### 003vite 中全局变量的使用 process


#### 007vite中使用process.env

~~~
import.meta.env打印
BASE_URL: "/"
DEV: true
MODE: "development"
PROD: false
SSR: false
MODE区分出来当前的命令
vite中非要用process
使用 vite 安装 vue3 时，如果使用了 process.env，会遇到 process 未定义的情况，原因是 process.env 已经被移除了。解决办法是在 vite.config.ts 中增加 define：
和server同级配置
define: {
        'process.env': {}
}

~~~

### 003 补充对于 vue2 历史项目中一般是使用 webpack，如何修改老项目成为 vite 脚手架基座。

之前腾讯出了一款 wp2vite，这个插件可以转 webpack 配置到 vite,但是需要配置的内容挺多。

好消息，有厉害的网友结合 wp2vite 出了一款，一键转 webpack 插件，可以尝试一下 webpack-vite-serve

[webpack-vite-serve - npm (npmjs.com)](https://www.npmjs.com/package/webpack-vite-serve)

[webpack 项目接入 Vite 通用方案介绍(下) (qq.com)](https://mp.weixin.qq.com/s/3VyfmV135Hi3Fvtal2oI0A)

###### 增加对于 webpack 插件和 vite 插件的配置比较

### 个人 webpack 转 vite 框架有一些简单的心得，仅仅用于简单配置的快速转换，见 processOn

[001---前端工程化系统梳理 ProcessOn Mind](https://www.processon.com/mindmap/617781871efad44894fbe29d)




### 006monorepo 项目介绍好处

Monorep 是把所有相关的 package 都放在一个仓库里进行管理，每个 package 独立发布。例如：React, Angular, Babel, Jest, Umijs, Vue

- 利用 pnpm 创建 monorepo 创建。
- Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。
  但是 yarn 和 lerna 配置多，使用 lerna 需要增加 package 中一些 lerna 配置，同时维护一个 leran.json，pnpm 只需要简单的房一个 yml 的管理文件，其他全部不变。

pnpm 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录，而通过硬链为你节省了磁盘空间并提升安装速度。

用于多种技术栈跨平台的多个项目，相同依赖相同过多。

```
1、多个项目统一规范，因为用到是同一个封装
2、不需要每个项目复制一遍，因为用到是同一个封装
3、request变动的时候，只需要改一处即可，因为用到是同一个封装
4、后续有新子项目时，可以使用现成的封装库
当前目录设置
├── README.md
├── package.json
├── apis---存放api接口
├── utils---存放公共库函数
├── components---存放各种组件库
├── packages
│   ├── web-viteclient---web端项目
│   └── h5-vite-client
│   └── admin-vite
└── pnpm-workspace.yaml---创建当前的项目和文件


```

#### 使用 npm init vue@3 和 npm create vite 区别

默认都是依赖 vite 框架搭建。
npm init vue@2 只能搭建 vue2 的 vite 框架。
npm init vue@3 只能搭建 vue3 的 vite 框架。
npm create 可以搭建多种语言的 vite 框架。

#### 搭建 webpack 的 vue 框架命令

之前 vue-cli 的命令行升级了，目前使用 vue create 可以创建 vue2 或是 vue3
npm i -g @vue/cli-init 安装全局，或是 npm install @vue/cli -g
然后创建项目
vue create xxx
(vue-cli3 集成了 webpack4)

-如果使用 webpack5,可以尝试下面的内容，没有试过

```
npm install -g @vue/cli@next#
OR
yarn global add @vue/cli@next
升级所有插件 Upgrade All Plugins at Once
vue upgrade --next

```

```

- vue2
npm install -g vue-cli;//验证vue -V
注意：vue2和vue3cli不能同时使用。



- vue3
npm install @vue/cli -g;//验证vue -V
(yarn安装 yarn global add @vue/cli)
vue create cli-vue2  // 创建cli-vue2项目  ，注意项目名称不能为驼峰
```

目前 vue3 中@vue/cli 已经被移除了，使用 npm i -g @vue/cli-init

然后 vue init webpack mytestwebpack

#### 创建步骤 monrepo 项目方式

###### 新建根目录

首先 Monorepo 需要一个根项目，所以我们先创建一个根项目，他相当于一个容器，用来存放我们的子项目，所以这个根项目并不需要安装太多的依赖

```

脚手架自己选pnpm create vite
vanilla---vite纯脚手架
vue
React
lit---lit+vite脚手架
Preact


```


##### Lit框架记录使用笔记指导
[Lit框架使用笔记汇总](https://mp.weixin.qq.com/s/h2146EMV8vmQbydBYr0CSw)

###### 创建 pnpm-workspace.yaml

新建 pnpm-workspace.yaml 文件，他的作用是：指定工作空间 workspace 的目录，里面的内容为：

```
packages:
  # 子项目存放的地方
  - 'packages/*'
  如果没有下面的可以放入一个包，其实怎么放都可以
  # 公用组件目录
  - 'components/**'
  # request目录
  - 'apis/**'
  # utils目录
  - 'utils/**'


```

###### 创建公用目录（建议是一个只含有脚手架的容器）

```
npm create vite

Project name: apis
Select a framework: › vanilla
Select a variant: › vanilla-ts

npm create vite

Project name: utils
Select a framework: › vanilla
Select a variant: › vanilla-ts

npm init vue@3

Project Name -> compnents
Typescript -> Yes
JSX -> Yes
Pinia -> Yes
Testing -> No
Eslint -> Yes


```

###### 子项目如何使用库：例如请求 api 库

https://mp.weixin.qq.com/s/y0cHuMxc7bC9Lhh5q2j5zQ

```
cd apis

npm i axios

创建和导出自己的apo封装代码后，
一般是接口请求拦截器和响应拦截器
然后src文件下，放一些模块的请求函数
在apis/src下创建：

request.ts---请求和响应拦截器
user.ts---api的封装接口

```

完成后，对于这个 apis 的包进行个性命令，因为这里的名称和版本号，决定了子项目引用时候这里的显示。

- 修改 name 和 version（在 package.json）

创建好之后，然后

###### 项目引用这个包的时候

```

首先进入某一个项:这里的package.json中的name就是这里的api-nyh名称
pnpm  install  apis-nyh -D
默认安装到生产环境。



- 项目测试使用api---注意这里有个使用方法
注意引入的时候，注意先把自己的版本删除，然后使用 pnpm  install  apis-nyh -D
如果是引用本地workspace的包，包名称前面加上@



---比如下面
import { getUser，createUser } from 'apis-nyh'


如果上面不生效
首先引入包后，在包前面加上一个@，就可以随意的使用了，比如原来的包名称是apis-nyh
使用的时候必须加上@apis-nyh
这样，所有的包都可以一目了然的使用了，只要将整个项目用@xxxx引入以后，都是模块化的使用方式了

import { getUser，createUser } from '@api-ts'

注意打包后，其实是一个对象输出，
例如：多个导入一个对象（多个export仅仅适用于单个项目中，如果这个项目做lib库，那么只能导出一个对象，对象上挂属性或是方法）
//!!!注意这里的坑，被坑了
 export const userApi = {
    addFn: () => {
        return add
    },
    getUserFn: () => {
        return getUser
    },
    createUserFn: () => {
        return createUser
    },
    getCommentScheduleWeekFn: () => {
        return getCommentScheduleWeek
    },
    getCommentScheduleDayFn: () => {
        return getCommentScheduleDay
    },
    getSingleMusicDetailsFn: () => {
        return getSingleMusicDetails
    },
};
```


###### 加快执行构建速度的 vue3 框架命令--skipLibCheck

```
一般项目vue3安装后，有一个脚本build，如下，但是有时候执行检查总是报错，那么可以跳过
pnpm i @test/utils -r --filter web-vite-client
"build": "vue-tsc --noEmit --skipLibCheck && vite build"


scripts.build 字段，原来里面执行了两条命令 vue-tsc --noEmit && vite build ，嗯？这个 vue-tsc 是干嘛的，查找了一下原来是对 vue 3 的一个类型检测工具，然后我尝试单独执行 vue-tsc --noEmit ，上面的报错出现了，原来是 vue-tsc 引起的错误。



```

###### 包安装操作

```
 把包安装在哪里
 -w 表示把包安装在 root 下，该包会放置在 <root>/node_modules 下。
 当然也可以把把安装在所有 packages 中，使用 -r 代替 -w。你必须使用其中一个参数。
 例如把 dayjs 装入 packages/web 下，packages/web 中的 package.json name 为 @test/web。
 需要执行：pnpm i dayjs -r --filter @test/web

命令如下
把包安装到所有的项目
pnpm i dayjs -r

把包安装在web-vite-client项目(项目名称package的name字段)
pnpm i color -r --filter web-vite-client



我们开发好apis包之后安装到web-vite-client中

pnpm i @nyh/apis -r --filter web-vite-client

pnpm i axios -r --filter @test/utils
pnpm i json-bigint -r --filter @test/utils
pnpm i @test/utils -r --filter web-vite-client


更新

pnpm up apis-ts -r --filter vue3-components
```

#### pnpm 项目配置需要增加配置全局 ts.config.json:注意第一点

```
全局的tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable", "webworker"],
    "moduleResolution": "Node",
    "esModuleInterop": true,---------允许当前的es模块
    "strict": true,
    "allowJs": true,
    "declaration": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "noEmitOnError": true,
    "noUnusedLocals": false,
    "noImplicitAny": false,
    "declarationMap": true,-------------为源文件创建一个d.ts生命
    "isolatedModules": true
  },
  "references": [------------------这部分放一些相关的package包的引用，这里做关系的连接，如果包之间有引用关系
    { "path": "packages/apis-ts" },
    { "path": "packages/vue3-components" },
    { "path": "web-vue3-vite-meituan-ts" }
  ]
}

```

#### 注意第二点：作为 utils 请求库，如果进行打包，配置 tsconfig 和 package

```
tsconfig.json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,------这个属性
    "rootDir": "./src",
    "outDir": "./dist"
  },
  "include": ["./src"]
}

package.json中配置：最后打包的类型（同时得益于全局tsconfig配置，declarationMap会生成.d.ts，自己不用创建了d.ts了）
{
    "name": "foo",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/foo.js",
    "typings": "./lib/foo.d.ts"
}
这里typeing是读取类型文件的路径，这个作为模块或是对外包的时候使用。
访问的时候尝试加载代码包路径下dist下的index.d.ts文件，这个文件也包含了文件类型信息。


```



### 一个 yarn 安装项目的有趣后门

yarn 安装包的时候，如果没有当前的 package.json 中的包，会让你选择当前的安装版本。
这样我们构建 vite 的项目或是其他项目可以使用 yarn 这个特性，选择版本脚手架。

比如讲 package.json 中的包后面多街上一个‘， "typescript": "^4.6.4'",

```
比如
  "devDependencies": {
    "@vitejs/plugin-vue": "^3.0.0",
    "typescript": "^4.6.4'",
    "vite": "^2.0.0'",
    "vue-tsc": "^0.38.4"
  }
  下面看到vite和ts都是后门版本多了一个'，这样显然没有这种版本，yarn就会列表出来。


```

### 一键给 vite 项目增加 eslint 和 prerttier

```
已经创建好的vite框架中，使用node16.5.0，创建vite项目后，然后在项目中，使用
npm init vite-pretty-lint
选择：vue-ts  yarn安装都可以实现。


```

### 三种 hash 区别（webpack 文件指纹策略）

使用 hash 对于 dev 开发环境的 js 进行打包设置，

使用 chunkhash 对于不同的入口 lib 的依赖库进行打包构建

使用 contenthash 对于 css 文件进行打包设置。

hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值。(粒度整个项目)(一个文件改变，整个项目重新构建，因为共用一个 hash)

chunkhash 是根据不同的入口进行依赖文件解析，构建对应的 chunk(模块)，生成对应的 hash 值。只有被修改的 chunk(模块)在重新构建之后才会生成新的 hash 值，不会影响其它的 chunk。(粒度 entry 的每个入口文件)(根据入口文件模块生成)

contenthash 是跟每个生成的文件有关，每个文件都有一个唯一的 hash 值。当要构建的文件内容发生改变时，就会生成新的 hash 值，且该文件的改变并不会影响和它同一个模块下的其它文件。(粒度每个文件的内容)

### 安装 webpack 的脚手架热更新修改后，没有自动刷新页面

如果是 webpack4 版本和 vuecli4，那么看看配置 hot:true 属性打开了，。

如果是纯 webpack3 版本，那么需要安装 webpack-dev-serve 版本，同时增加到脚本中。

### vite 脚手架有时候修改本地代码调试，无法同步更新浏览器展示

#### 不要犯文件导入不一致命名的问题

#### 配置 vite 的脚手架属性 hmr：true

#### 如果配置后，发现还是刷新后，代码没有同步，命令行原因（可能）

由于 WSL2 的限制，vite 默认配置是无法监控 windows 文件系统中文件的变化的。
所以方法 1：换一个命令行工具，比如 powershell 换成 gitbash
方法 2：配置 vite 内容

```
 server: {
    watch: {
      { usePolling: true }
    }
  }

```

### webpack 没有热更新

#### 在 webpack4 版本中，增加 webpack-dev-server 安装包，然后，在脚本启动的时候增加 webpack-dev-server，同时配置 devServer 的 hot:true

热更新是页面刷新 reload 的情况
解决办法：（ 怀疑和 node 版本有关系）

```

dev模式下，不能用merge。('webpack-merge')
dev模式下，不能用 MiniCssExtractPlugin.loader

```

"dev":中增加"webpack-dev-server --hot --open --progress",
--hot 不能少，或者 devServer 里配置 hot: true

#### 如果有时候父子组件，子组件改完后，没有动静。

那么根据渲染机制，给父组件写一个 js 文件修改，启动更新生命周期。

#### webpack5 热更新失效，那么配置 target

```
// 在entry和output的同级处，加上  target: 'web'
module.exports = {
    target: 'web',
    entry,
    output: {
        path: path.resolve(__dirname, 'dist')
    },
  ...
}


```

#### 脚手架格式化实现解决方案

[000---前端架构师管理体系化管理学习-前端代码格式化配置](https://app.yinxiang.com/shard/s37/nl/24388549/717c6df8-60ec-4a80-b02e-c968f44016df)


### 关于代码库是否可以使用 git 进行文件授权管理

如果要的就是集中式的管理模式，那用 Git 干嘛呢？使用 svn.

从技术上将，Git 可能永远也做不到类似 SVN 的路径授权（读授权）

- Git 服务器的部署实际上可以使用钩子对分支和路径进行写授权，即可以控制谁能够创建分支，能够写特定文件。
- 公司对代码库进行合理分解，对每个代码库分别授权。即某个代码库对团队成员完全开放，对其它团队完全封闭。

#### 有人可能想到利用 git 的下载单个文件夹命令

但是这个对于程序员来说是骗人的，可以自己进入 git 的 info 文件夹下的 sparse-checkout 文件夹，指定下载哪些文件夹。

```
- 具体使用在当前的命令行下创建一个文件夹
- 进入文件夹后git init
- 然后进入git的info文件夹创建一个sparse-checkout文件，添加想要下载的文件夹
注意：根目录使用/,比如下载根目录下的src:/src/*
- 配置git支持modules下载
git config core.sparseCheckout true

- 在当前的文件夹下下载项目

```
